<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>To Do List v0.0.1</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <style>
    :root {
      --bg-dark: #121212;
      --card-bg: #1e1e1e;
      --input-bg: #2d2d2d;
      --border: #333;
      --text: #e0e0e0;
      --red-text: #ff6b6b;
      --blue-select: #339af0;
      --success: #28a745;
      --primary: #0d6efd;
      --orange: #e67700;
      --purple: #9c27b0;
    }

    body { 
      background: var(--bg-dark); 
      color: var(--text); 
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
      min-height: 100vh;
      margin: 0;
      padding-bottom: 2rem;
    }

    .main-card {
      background: var(--card-bg);
      border: 1px solid var(--border);
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      padding: 1.5rem;
      margin: 1rem;
      display: flex;
      flex-direction: column;
    }

    @media (min-width: 769px) {
      .main-card { max-width: 1200px; margin: 2rem auto; }
    }

    .form-control, .form-select, textarea {
      background: var(--input-bg);
      border: 1px solid #444;
      color: #fff;
      border-radius: 8px;
    }
    .form-control:focus, .form-select:focus, textarea:focus {
      background: #333;
      border-color: var(--primary);
      box-shadow: 0 0 0 0.2rem rgba(13, 110, 253, 0.25);
      color: #fff;
    }

    .btn-primary { background: var(--primary); border: none; }
    .btn-success { background: var(--success); border: none; }
    .btn-secondary { background: #6c757d; border: none; }
    .btn-danger { background: #dc3545; border: none; color: white; }
    .btn-orange { background: var(--orange); border: none; color: white; }
    .btn-blue { background: #1e90ff; border: none; }
    .btn-purple { background: var(--purple); border: none; }
    .btn-primary:hover { background: #0b5ed7; }
    .btn-success:hover { background: #218838; }
    .btn-danger:hover { background: #c82333; }
    .btn-orange:hover { background: #c65f00; }
    .btn-blue:hover { background: #1c7ed6; }
    .btn-purple:hover { background: #7b1fa2; }

    .section-frame {
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 1rem;
      margin-bottom: 1rem;
      background: var(--card-bg);
      width: 100%;
      box-sizing: border-box;
    }

    .section-title {
      font-size: 16px;
      font-weight: bold;
      color: var(--primary);
      margin-bottom: 0.5rem;
    }

    .form-label { color: #bbbbbb; font-weight: 600; font-size: 0.9em; }
    small { color: #999; font-size: 0.85em; }
    h2 { color: var(--primary); text-align: center; margin-bottom: 1.5rem; }
    
    /* Gallery View Styles */
    .gallery-item {
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 0.5rem;
      border-radius: 8px;
      background: var(--input-bg);
      border: 2px solid transparent;
      transition: all 0.3s ease;
      cursor: pointer;
      width: 100%;
      min-width: 0;
      overflow: hidden;
    }
    
    .gallery-item.selected {
      border-color: #00ffff;
      box-shadow: 0 0 15px rgba(0, 255, 255, 0.6), 0 0 30px rgba(0, 255, 255, 0.4);
    }
    
    .gallery-item:hover {
      background: #333;
      transform: translateY(-2px);
    }
    
    .gallery-thumbnail {
      width: 100%;
      height: 150px;
      min-height: 150px;
      object-fit: cover;
      border-radius: 4px;
      background: var(--card-bg);
      border: 1px solid var(--border);
      display: block;
    }
    
    .gallery-thumbnail.loading {
      opacity: 0.5;
      background: var(--input-bg);
    }
    
    .gallery-info {
      margin-top: 0.5rem;
      text-align: center;
      width: 100%;
    }
    
    .gallery-filename {
      font-size: 0.75em;
      color: var(--text);
      word-break: break-word;
      font-weight: 500;
    }
    
    .gallery-subfolder {
      font-size: 0.65em;
      color: #999;
      margin-top: 0.25rem;
      font-style: italic;
    }

    .progress { height: 12px; background: var(--input-bg); border-radius: 6px; }
    .progress-bar { background: var(--success); }

    .status-label {
      font-size: 0.85em;
      color: #999;
      margin-top: 0.25rem;
    }

    /* Console Output */
    .console-output {
      background: #000;
      border: 1px solid #444;
      border-radius: 8px;
      color: #0f0;
      font-family: 'Courier New', monospace;
      font-size: 0.8em;
      padding: 0.75rem;
      height: 300px;
      overflow-y: auto;
      margin-top: 1rem;
      white-space: pre-wrap;
      word-wrap: break-word;
    }

    .console-output .error { color: #ff6b6b; }
    .console-output .success { color: #51cf66; }
    .console-output .info { color: #339af0; }
    .console-output .warning { color: #ffd43b; }

    .input-row {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-bottom: 0.5rem;
    }

    .input-row label {
      min-width: 150px;
      margin-bottom: 0;
    }

    .input-row input, .input-row select {
      flex: 1;
    }

    .btn-row {
      display: flex;
      gap: 0.5rem;
      justify-content: center;
      flex-wrap: wrap;
      margin-top: 1rem;
    }

    .products-display {
      background: var(--input-bg);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 1rem;
      max-height: 300px;
      overflow-y: auto;
      margin-top: 0.5rem;
    }

    .product-item {
      padding: 0.25rem 0;
      color: var(--text);
    }

    /* Modal/Popup Styles */
    .modal-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      z-index: 1000;
      justify-content: center;
      align-items: center;
    }

    .modal-overlay.show {
      display: flex;
    }

    .modal-content {
      background: var(--card-bg);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 2rem;
      max-width: 700px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
      box-shadow: 0 4px 20px rgba(0,0,0,0.5);
    }

    .modal-header {
      font-size: 1.3rem;
      font-weight: bold;
      color: var(--primary);
      margin-bottom: 1rem;
    }

    .script-display {
      background: #000;
      border: 1px solid #444;
      border-radius: 8px;
      padding: 1rem;
      font-family: 'Courier New', monospace;
      font-size: 0.85em;
      color: #0f0;
      max-height: 300px;
      overflow-y: auto;
      white-space: pre-wrap;
      word-wrap: break-word;
      margin-bottom: 1rem;
    }

    .script-display.truncated::after {
      content: '\n\n... (script continues - use Copy Script to get full version)';
      color: #999;
    }

    .modal-buttons {
      display: flex;
      gap: 0.5rem;
      justify-content: flex-end;
      flex-wrap: wrap;
    }

    .modal-buttons .btn {
      min-width: 140px;
    }

    /* Gallery Styles */
    .gallery-modal {
      max-width: 98vw;
      width: 98vw;
      max-height: 95vh;
    }

    .gallery-header {
      border-bottom: 1px solid #222638;
      padding-bottom: 0.5rem;
      margin-bottom: 0.5rem;
    }

    .gallery-title {
      font-size: 1.4rem;
      font-weight: 600;
      color: #fff;
    }

    .gallery-subtitle {
      color: #adb5ff;
      font-size: 0.9rem;
      margin-top: 0.25rem;
    }

    .gallery-instruction {
      color: #ff6b6b;
      font-size: 0.9rem;
      min-height: 1.2rem;
      margin-bottom: 0.25rem;
    }

    .gallery-toolbar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 0.75rem;
      margin-bottom: 1rem;
    }

    .gallery-toolbar-left,
    .gallery-toolbar-right {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
    }

    .gallery-grid {
      display: flex;
      flex-direction: column;
      gap: 0.35rem; /* Further reduced gap to fit 2 rows without scrollbar */
      max-height: calc(100vh - 320px); /* Adjusted to fit 2 rows without scrollbar */
      overflow-y: auto;
      padding-right: 0.5rem;
    }

    .variant-row {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
    }

    .gallery-group {
      border: 1px solid #1f2233;
      border-radius: 12px;
      padding: 0.4rem 0.6rem 0.4rem; /* Reduced padding to save vertical space */
      background: #111321;
      box-shadow: 0 4px 12px rgba(0,0,0,0.25);
      margin-bottom: 0; /* Remove margin-bottom, gap handles spacing */
    }

    .gallery-group-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.35rem; /* Reduced margin to save space */
    }

    .gallery-group-header h5 {
      margin: 0;
      font-size: 1rem;
      color: #fff;
      margin-right: auto;
    }

    .gallery-controls {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      margin-left: auto;
    }

    .skip-checkbox {
      width: 20px;
      height: 20px;
      cursor: pointer;
      accent-color: #ff6b6b;
      filter: hue-rotate(0deg) saturate(1.2);
      appearance: none;
      -webkit-appearance: none;
      border: 2px solid #ff6b6b;
      border-radius: 3px;
      background-color: transparent;
      position: relative;
    }
    
    .skip-checkbox:checked {
      background-color: #ff6b6b;
    }
    
    .skip-checkbox:checked::after {
      content: '‚úì';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-size: 14px;
      font-weight: bold;
    }

    .refresh-btn {
      background: var(--input-bg);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text);
      padding: 0.4rem 0.6rem;
      cursor: pointer;
      font-size: 0.85rem;
      display: flex;
      align-items: center;
      gap: 0.3rem;
      transition: all 0.2s ease;
    }

    .refresh-btn:hover {
      background: #333;
      border-color: var(--primary);
    }

    .refresh-btn:active {
      transform: scale(0.95);
    }

    .refresh-btn.loading {
      opacity: 0.6;
      cursor: not-allowed;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }

    .gallery-group.skipped {
      opacity: 0.5;
      background: rgba(255, 107, 107, 0.1);
      border-color: rgba(255, 107, 107, 0.5);
    }

    .gallery-group.skipped .gallery-group-header h5 {
      text-decoration: line-through;
      color: #999;
    }

    .new-images-badge {
      position: absolute;
      top: 0.5rem;
      right: 0.5rem;
      background: var(--success);
      color: white;
      font-size: 0.7rem;
      padding: 0.2rem 0.4rem;
      border-radius: 4px;
      font-weight: bold;
      z-index: 5;
    }

    .gallery-card.new-image {
      position: relative;
    }

    .gallery-item-id {
      color: #9aa4d3;
      font-size: 0.8rem;
      display: inline-block;
      margin-top: 0.15rem;
    }

    .gallery-card {
      background: #080b14;
      border: 1px solid #242b44;
      border-radius: 12px;
      padding: 0.5rem; /* Reduced padding to ensure halo visibility */
      width: 200px; /* Slightly reduced to ensure full halo visibility with margin */
      min-width: 200px;
      max-width: 200px;
      flex-shrink: 0;
      display: flex;
      flex-direction: column;
      gap: 0.35rem; /* Reduced gap between card elements */
      cursor: pointer;
      transition: border 0.2s ease, transform 0.2s ease, box-shadow 0.2s ease;
      margin: 3px; /* Add margin to ensure halo is fully visible */
    }

    .url-positions-fixed {
      background: rgba(40, 167, 69, 0.15); /* Light green background around positions 1-2 */
      border: 2px solid #28a745; /* Bright green border matching Download Selected Items button */
      border-radius: 12px;
      padding: 8px;
      margin-bottom: 12px;
    }

    .gallery-card.url-position-card {
      /* Keep same styling as regular gallery cards */
      background: #080b14;
      border: 1px solid #242b44;
    }

    .gallery-card.url-position-card:hover {
      border-color: #3a3f5a;
      box-shadow: 0 0 0 2px rgba(40, 167, 69, 0.2);
    }

    .gallery-card-image {
      border-radius: 10px;
      overflow: hidden;
      background: #000;
      height: 110px; /* Reduced to fit better with smaller card */
    }

    .gallery-card-image img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .gallery-card-body {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.8rem; /* Slightly reduced font size */
    }

    .gallery-card-title {
      font-weight: 600;
      color: #fff;
      white-space: nowrap; /* Force Variant X to stay on one line */
      overflow: hidden;
      text-overflow: ellipsis; /* Show ellipsis if text is too long */
    }

    .gallery-card-source {
      color: #9aa4d3;
      font-size: 0.7rem; /* Slightly reduced font size */
      text-align: right;
      word-break: break-word; /* Allow URL text to wrap multiple lines */
    }

    .gallery-preview-btn {
      border: 1px solid #3f4b6b;
      border-radius: 999px;
      padding: 0.2rem 0.8rem;
      font-size: 0.75rem;
      background: transparent;
      color: #fff;
      align-self: flex-start;
      transition: background 0.2s ease, color 0.2s ease;
    }

    .gallery-preview-btn:hover {
      background: #3f4b6b;
    }

    .gallery-card.selected {
      border-color: #2f9e44;
      box-shadow: 0 0 0 3px rgba(47, 158, 68, 0.5); /* Increased halo visibility */
      transform: translateY(-2px);
      margin: 3px; /* Ensure margin is maintained when selected */
    }

    /* URL Row Container Styles */
    .url-row-container {
      margin-bottom: 1.5rem;
    }

    .url-row-container:last-child {
      margin-bottom: 0;
    }

    .url-row-label {
      font-size: 0.85em;
      color: #9aa4d3;
      font-weight: 600;
      margin-bottom: 0.5rem;
      padding-left: 0.25rem;
    }

    /* Placeholder Styles - Option 5: Clean X with Gradient */
    .placeholder-x {
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: linear-gradient(135deg, #2d2d2d 0%, #1e1e1e 100%);
      border: 2px dashed #dc3545;
      color: #dc3545;
    }

    .placeholder-x .x-icon {
      font-size: 4em;
      font-weight: bold;
      line-height: 1;
      margin-bottom: 0.5rem;
      opacity: 0.7;
    }

    .placeholder-x .x-text {
      font-size: 0.75em;
      color: #bbbbbb;
      text-align: center;
      padding: 0 0.5rem;
    }

    .variant-slider {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .slider-viewport {
      overflow: hidden;
      flex: 1;
    }

    .slider-track {
      display: flex;
      gap: 0.5rem; /* Reduced gap between cards in slider */
      transition: transform 0.3s ease;
      width: max-content; /* Ensure track is wide enough for all cards */
    }

    .slider-nav-btn {
      background: transparent;
      border: 1px solid #3f4b6b;
      color: #fff;
      border-radius: 50%;
      width: 36px;
      height: 36px;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 1rem;
    }

    .variant-slider.no-nav .slider-nav-btn {
      visibility: hidden;
    }

    .gallery-warning {
      background: rgba(230, 119, 0, 0.15);
      border: 1px solid var(--orange);
      border-radius: 8px;
      padding: 0.75rem;
      color: #ffc078;
      margin-bottom: 0.5rem;
      font-size: 0.9rem;
    }

    .hidden-warning {
      display: none;
    }

    .gallery-empty {
      font-size: 0.85rem;
      color: #bbb;
      border: 1px dashed #444;
      border-radius: 8px;
      padding: 0.5rem;
      text-align: center;
    }

    .gallery-footer-status {
      margin-top: 0.5rem;
      font-size: 0.85rem;
      color: #bbb;
      min-height: 1.2em;
    }

    .carousel-modal {
      max-width: 900px;
      width: 95%;
      max-height: 90vh; /* Increased from default to accommodate content below image */
    }

    .carousel-body {
      display: flex;
      align-items: center;
      gap: 1rem;
      margin-bottom: 1rem; /* Add space between image and caption */
    }

    .carousel-image {
      flex: 1;
      border-radius: 12px;
      overflow: hidden;
      background: #000;
      height: 500px; /* Increased from 420px to give more space */
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .carousel-image img {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
    }

    .carousel-nav-btn {
      background: transparent;
      border: 1px solid #3f4b6b;
      color: #fff;
      border-radius: 50%;
      width: 42px;
      height: 42px;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 1.1rem;
    }

    .carousel-caption {
      background: #1a1d2e; /* Grey background section */
      border-radius: 8px;
      padding: 1rem 1.25rem; /* Generous padding */
      margin-top: 1rem; /* Space above the grey section */
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.9rem;
      color: #fff; /* Ensure text is visible */
      border: 1px solid #242b44; /* Subtle border */
    }

    .carousel-caption a {
      color: #66d9ff;
      text-decoration: underline;
      font-size: 0.85rem;
    }
  </style>
</head>
<body>
  <!-- Gallery Modal -->
  <div class="modal-overlay" id="galleryModal">
    <div class="modal-content gallery-modal">
      <div class="modal-header gallery-header">
        <div>
          <div class="gallery-title">Review Images</div>
          <div class="gallery-subtitle" id="gallerySelectionSummary">0 of 0 items selected</div>
        </div>
      </div>
      <div class="gallery-instruction" id="galleryInstructionMessage"></div>
      <div class="gallery-toolbar">
        <div class="gallery-toolbar-left">
          <button id="gallerySelectFirstBtn" class="btn btn-outline-light btn-sm">Auto Select Images</button>
          <button id="galleryRefreshBtn" class="btn btn-outline-light btn-sm">Refresh Gallery</button>
        </div>
      <div class="gallery-toolbar-right">
        <button id="galleryCloseBtn" class="btn btn-danger btn-sm">Cancel</button>
        </div>
      </div>
      <div id="galleryWarnings"></div>
      <div class="gallery-grid" id="galleryGrid"></div>
      <div class="gallery-footer-status" id="galleryFooterStatus"></div>
      <div class="gallery-footer-actions" style="display: flex; justify-content: flex-end; align-items: center; gap: 0.5rem; margin-top: 1rem; padding-top: 1rem; border-top: 1px solid var(--border); flex-wrap: wrap;">
        <div style="display: flex; align-items: center; gap: 0.5rem;">
          <input type="checkbox" id="uploadAfterDownloadGallery" style="margin: 0; cursor: pointer;">
          <label for="uploadAfterDownloadGallery" style="margin: 0; cursor: pointer; color: var(--text); font-size: 0.9em;">Upload to Cloudinary after download</label>
        </div>
        <div style="display: flex; align-items: center; gap: 0.5rem;">
          <input type="checkbox" id="updateWmAfterDownloadGallery" style="margin: 0; cursor: pointer;">
          <label for="updateWmAfterDownloadGallery" style="margin: 0; cursor: pointer; color: var(--text); font-size: 0.9em;">Update WM after download</label>
        </div>
        <button id="gallerySaveBtn" class="btn btn-success btn-sm" disabled>Download Selected Items</button>
      </div>
    </div>
  </div>
  <!-- Variant Carousel Modal -->
  <div class="modal-overlay" id="carouselModal">
    <div class="modal-content carousel-modal">
      <div class="modal-header d-flex justify-content-between align-items-center">
        <span id="carouselTitle"></span>
        <button class="btn btn-outline-secondary btn-sm" id="carouselCloseBtn">Close</button>
      </div>
      <div class="carousel-body">
        <button class="carousel-nav-btn" id="carouselPrevBtn" type="button">&#8249;</button>
        <div class="carousel-image">
          <img id="carouselImage" src="" alt="Variant preview">
        </div>
        <button class="carousel-nav-btn" id="carouselNextBtn" type="button">&#8250;</button>
      </div>
      <div class="carousel-caption">
        <div id="carouselVariantLabel"></div>
        <div style="display:flex;align-items:center;gap:0.5rem;flex-wrap:wrap;">
          <a id="carouselOpenOriginal" href="#" target="_blank" rel="noopener noreferrer">Open original</a>
          <button class="btn btn-success btn-sm" id="carouselUseBtn" type="button">Use This Image</button>
        </div>
      </div>
    </div>
  </div>
  <div class="main-card">
    <h2>To Do List v0.0.1</h2>

    <!-- ============================================================================= -->
    <!-- SECTION 1: GENERATE ITEMS -->
    <!-- ============================================================================= -->
    <div class="section-frame">
      <div class="section-title">Generate Items</div>
      
      <div class="input-row">
        <label class="form-label">Existing Item List:</label>
        <div style="flex:1; position: relative;">
        <input type="file" id="items_file" class="form-control" accept=".csv,.xls,.xlsx" style="display:none;" />
          <input type="text" id="existing_list" class="form-control" placeholder="Load a CSV/Excel file" style="flex:1; padding-right: 200px; text-overflow: ellipsis; overflow: hidden; white-space: nowrap; background-color: rgba(255, 0, 0, 0.1); border-color: rgba(255, 0, 0, 0.3);" readonly />
          <span id="existingListStatus" style="position: absolute; right: 8px; top: 50%; transform: translateY(-50%); color: var(--success); font-size: 0.85em; pointer-events: none; white-space: nowrap;"></span>
        </div>
        <button class="btn btn-secondary btn-sm" id="existingListLoadBtn" type="button">Load</button>
      </div>

      <div class="input-row">
        <label class="form-label">Reference Items File:</label>
        <div style="flex:1; position: relative;">
          <input type="file" id="item_numbers_csv" class="form-control" accept=".csv,.xls,.xlsx" style="display:none;" />
          <input type="text" id="reference_items_display" class="form-control" placeholder="Load or enter a CSV/Excel file path" style="padding-right: 200px; text-overflow: ellipsis; overflow: hidden; white-space: nowrap; background-color: rgba(255, 0, 0, 0.1); border-color: rgba(255, 0, 0, 0.3);" readonly />
          <span id="itemNumbersStatus" style="position: absolute; right: 8px; top: 50%; transform: translateY(-50%); color: var(--success); font-size: 0.85em; pointer-events: none; white-space: nowrap;"></span>
      </div>
        <button class="btn btn-secondary btn-sm" id="referenceItemsLoadBtn" type="button" title="CSV/Excel file with item numbers (one per row, first column)">Load</button>
      </div>

      <div class="input-row">
        <label class="form-label">Images Per Item:</label>
        <input type="number" id="images_per_item" class="form-control" placeholder="3" min="1" />
      </div>

      <div class="input-row">
        <label class="form-label">Preferred Sites:</label>
        <input type="text" id="sites" class="form-control" placeholder="nike.com, amazon.com" />
      </div>

      <div class="input-row">
        <label class="form-label">Image Filters:</label>
        <input type="text" id="image_filters" class="form-control" placeholder="large, photo, png" />
        <small>Options: large, photo, png, red, etc.</small>
      </div>

      <div class="btn-row" style="display: flex; justify-content: flex-start; align-items: flex-start; gap: 1rem; flex-wrap: wrap;">
        <button id="genBtn" class="btn btn-success" style="width: 200px; display: none;">Generate Items</button>
        <div style="display: flex; flex-direction: column; gap: 0.5rem;">
          <div style="display: flex; align-items: center; gap: 0.5rem;">
            <input type="checkbox" id="uploadAfterDownload" style="margin: 0; cursor: pointer;">
            <label for="uploadAfterDownload" style="margin: 0; cursor: pointer; color: var(--text); font-size: 0.9em;">Upload to Cloudinary after download</label>
          </div>
          <div style="display: flex; align-items: center; gap: 0.5rem;">
            <input type="checkbox" id="updateWmAfterDownload" style="margin: 0; cursor: pointer;">
            <label for="updateWmAfterDownload" style="margin: 0; cursor: pointer; color: var(--text); font-size: 0.9em;">Update WM after download</label>
          </div>
        </div>
      </div>
      <div style="display: flex; justify-content: center; margin-top: 1rem;">
        <button id="dlBtn" class="btn btn-success" style="width: 200px;">Download Items</button>
      </div>

      <div class="progress mt-2" id="genProgress" style="display: none;">
        <div class="progress-bar" role="progressbar" style="width: 0%"></div>
      </div>
      <div class="progress mt-2" id="dlProgress" style="display: none;">
        <div class="progress-bar" role="progressbar" style="width: 0%"></div>
      </div>
      <div class="status-label" id="genStatus"></div>
      <div class="status-label" id="dlStatus"></div>

    </div>

    <!-- ============================================================================= -->
    <!-- SECTION 2: WORKFLOW -->
    <!-- ============================================================================= -->
    <div class="section-frame">
      <div class="section-title">Additional Parameters</div>

      <div class="input-row">
        <label class="form-label">Update Item CSV File:</label>
        <div style="flex:1; position: relative;">
          <input type="file" id="csv_out_file" class="form-control" accept=".csv,.xls,.xlsx" style="display:none;" />
          <input type="text" id="csv_out" class="form-control" placeholder="Load or enter a CSV/Excel file path" style="flex:1; padding-right: 200px; text-overflow: ellipsis; overflow: hidden; white-space: nowrap; background-color: rgba(255, 0, 0, 0.1); border-color: rgba(255, 0, 0, 0.3);" readonly />
          <span id="csvOutStatus" style="position: absolute; right: 8px; top: 50%; transform: translateY(-50%); color: var(--success); font-size: 0.85em; pointer-events: none; white-space: nowrap;"></span>
        </div>
        <button class="btn btn-secondary btn-sm" id="csvOutLoadBtn" type="button">Load</button>
      </div>

      <div class="input-row">
        <label class="form-label">Cloudinary Prefix:</label>
        <input type="text" id="prefix" class="form-control" placeholder="https://res.cloudinary.com/..." />
      </div>

      <div class="input-row">
        <label class="form-label">Cloudinary Folder:</label>
        <input type="text" id="upload_folder" class="form-control" placeholder="sidney" />
      </div>

      <div class="input-row">
        <label class="form-label">Upload Preset:</label>
        <input type="text" id="upload_profile" class="form-control" placeholder="Optional preset name" />
      </div>

      <div class="input-row">
        <label class="form-label">Image Directory:</label>
        <input type="file" id="save_dir_file" class="form-control" webkitdirectory directory style="display: none;" />
        <input type="text" id="save_dir" class="form-control" placeholder="Select directory for cleanup/upload reference" style="flex: 1;" />
        <button id="chooseDirBtn" class="btn btn-secondary btn-sm" type="button">Choose Directory</button>
        <div style="display: flex; align-items: center; gap: 0.5rem; margin-left: 0.5rem;">
          <input type="checkbox" id="include_subfolders" style="margin: 0;" />
          <label for="include_subfolders" style="margin: 0; font-size: 0.9em; color: var(--text);">Include subfolders</label>
        </div>
      </div>

      <!-- Image Preview Section -->
      <div id="imagePreviewContainer" style="display: none; margin-top: 0.5rem; margin-left: 1rem; padding: 0.75rem; background: var(--input-bg); border: 2px solid var(--primary); border-radius: 6px;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
          <div style="font-size: 0.95em; color: var(--text); font-weight: bold;">
            <span style="color: var(--primary);">üìÅ Images:</span> <span id="imageCount" style="color: var(--success);">0</span> file(s) | 
            <span style="color: var(--primary); margin-left: 0.5rem;">Selected:</span> <span id="selectedCount" style="color: var(--success);">0</span>
          </div>
          <div style="display: flex; gap: 0.5rem;">
            <button id="selectAllImages" class="btn btn-secondary btn-sm" type="button" style="font-size: 0.8em; padding: 0.25rem 0.5rem;">Select All</button>
            <button id="deselectAllImages" class="btn btn-secondary btn-sm" type="button" style="font-size: 0.8em; padding: 0.25rem 0.5rem;">Deselect All</button>
          </div>
        </div>
        <div id="imagePreviewList" style="max-height: 400px; overflow-y: auto; background: var(--input-bg); border: 1px solid var(--border); border-radius: 4px; padding: 0.75rem; display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 1rem;">
          <!-- Image gallery will be populated here -->
        </div>
        <div id="imagePreviewNote" style="font-size: 0.8em; color: #999; margin-top: 0.5rem; font-style: italic;">
          Note: The browser may show "Upload 30 files" in the native dialog - this is normal. After confirming, the preview above shows the filtered count based on your "Include subfolders" setting. Click images to toggle selection (selected images have a cyan halo).
        </div>
      </div>

      <div class="btn-row">
        <button id="cleanupBtn" class="btn btn-orange" style="width: 160px; display: none;">Clean Up CSV</button>
        <button id="upBtn" type="button" class="btn btn-blue" style="width: 160px;">Upload to Cloudinary</button>
        <button id="wmBtn" class="btn btn-purple" style="width: 160px;">Update WM</button>
      </div>
      
      <!-- Upload Progress Bar -->
      <div id="uploadProgressContainer" style="display: none; margin-top: 1rem;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
          <div style="font-size: 0.9em; color: var(--text);">
            <span id="uploadProgressText">Uploading...</span>
            <span id="uploadTimeRemaining" style="margin-left: 1rem; color: #999;"></span>
          </div>
          <div style="font-size: 0.9em; color: var(--text);">
            <span id="uploadProgressPercent">0%</span>
          </div>
        </div>
        <div style="width: 100%; height: 8px; background: var(--input-bg); border-radius: 4px; overflow: hidden;">
          <div id="uploadProgressBar" style="height: 100%; background: var(--success); width: 0%; transition: width 0.3s ease;"></div>
        </div>
      </div>

    </div>

    <!-- ============================================================================= -->
    <!-- CONSOLE WINDOW (For Troubleshooting) -->
    <!-- ============================================================================= -->
    <div class="section-frame">
      <div class="section-title">Console</div>
      <div class="console-output" id="console"></div>
    </div>
  </div>

  <script>
    const APP_VERSION = 'v0.0.1';
    const DEFAULTS = {
      company: "Nike",
      website: "nike.com",
      count: 30,
      sites: "nike.com, amazon.com",
      images_per_item: 3,
      prefix: "https://res.cloudinary.com/com-manh-cp/image/upload/v1752528139/sidney/",
      upload_folder: "sidney",
      upload_profile: "",
      extra_prompt: "",
      image_filters: "",
      existing_list: "items.txt",
      csv_out: "imagedownload.csv",
      save_dir: "/tmp/images"
    };

    let generatedProducts = [];
    let generatedOutputText = '';
    let referenceItems = [];
    let currentItemList = [];
    let galleryItems = [];
    let gallerySelections = {};
    let gallerySkippedItems = new Set(); // Track skipped items
    let galleryNewImages = new Map(); // Track new images per item: Map<itemId, Set<fileName>>
    let galleryMissingItems = [];
    let lastGalleryPayload = null;
    let galleryLoading = false;
    let gallerySliderPositions = {}; // Track slider positions per item: Map<uniqueKey, index>
    let csvData = null;
    let loadedCsvData = null; // CSV data from loaded file
    let posItemsData = []; // Structured todo items data: [{itemId, imageURL1, imageURL2, shortDescription}, ...]
    let sessionOrg = null; // ORG stored in session (resets on refresh)
    let sessionToken = null; // Token stored in session (resets on refresh)
    let orgFromUrl = false; // Flag to track if ORG came from URL
    let carouselGroup = null;
    let carouselIndex = 0;

    function loadConfig() {
      const config = {};
      for (const key in DEFAULTS) {
        const stored = localStorage.getItem(`item_gen_${key}`);
        config[key] = stored !== null ? stored : DEFAULTS[key];
      }
      return config;
    }

    function saveConfig() {
      const config = {};
      
      // Only save config for elements that exist (some were removed for todo items)
      const configMap = {
        company: 'company',
        website: 'website',
        count: 'count',
        sites: 'sites',
        images_per_item: 'images_per_item',
        prefix: 'prefix',
        upload_folder: 'upload_folder',
        upload_profile: 'upload_profile',
        extra_prompt: 'extra_prompt',
        image_filters: 'image_filters',
        existing_list: 'existing_list',
        csv_out: 'csv_out',
        save_dir: 'save_dir'
      };

      for (const key in configMap) {
        const elementId = configMap[key];
        const element = document.getElementById(elementId);
        if (element) {
          config[key] = element.value;
        }
      }

      for (const key in config) {
        if (config[key]) {
          localStorage.setItem(`item_gen_${key}`, config[key]);
        }
      }
    }

    function getDesktopPath() {
      if (navigator.platform.toLowerCase().includes('win')) {
        return 'C:\\Users\\User\\Desktop\\';
      } else if (navigator.platform.toLowerCase().includes('mac')) {
        return '~/Desktop/';
      }
      return '~/Desktop/';
    }

    function normalizePathDefaults(config) {
      const hasStoredConfig = Object.keys(localStorage).some(key => key.startsWith('item_gen_'));
      if (hasStoredConfig) return config;
        const desktopPath = getDesktopPath();
        if (config.existing_list && !config.existing_list.includes('/') && !config.existing_list.includes('\\')) {
          config.existing_list = desktopPath + config.existing_list;
        }
        if (config.csv_out && !config.csv_out.includes('/') && !config.csv_out.includes('\\')) {
          config.csv_out = desktopPath + config.csv_out;
        }
        if (!config.save_dir || config.save_dir === DEFAULTS.save_dir) {
          config.save_dir = '';
        }
      return config;
      }

    // Function to filter image files (shared by preview and upload) - defined at global scope
    function filterImageFiles(files, includeSubfolders) {
        console.log('üîç [FILTER] Starting filterImageFiles');
        console.log('üîç [FILTER] Parameters:', { 
          totalFiles: files ? files.length : 0, 
          includeSubfolders: includeSubfolders 
        });
        
        const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.bmp'];
        let totalFiles = 0;
        let rootFiles = 0;
        let subfolderFiles = 0;
        let nonImageFiles = 0;
        let filteredRootFiles = 0;
        let filteredSubfolderFiles = 0;
        
        const filtered = Array.from(files).filter((file, index) => {
          totalFiles++;
          
          // Log first 5 files for debugging
          if (index < 5) {
            console.log(`üîç [FILTER] File ${index + 1}:`, {
              name: file.name,
              webkitRelativePath: file.webkitRelativePath || '(none)',
              size: file.size,
              type: file.type
            });
          }
          
          // Check file extension
          const ext = file.name.toLowerCase().substring(file.name.lastIndexOf('.'));
          if (!imageExtensions.includes(ext)) {
            nonImageFiles++;
            if (index < 5) {
              console.log(`üîç [FILTER] File ${index + 1} rejected: not an image (ext: ${ext})`);
            }
            return false;
          }
          
          // If subfolders not included, exclude files that are in subfolders
          if (!includeSubfolders && file.webkitRelativePath) {
            const relativePath = file.webkitRelativePath;
            const pathSegments = relativePath.split('/');
            // When selecting a folder with webkitdirectory, the path includes the folder name:
            // Root files: webkitRelativePath = "images/filename.jpg" (2 segments: folder + filename)
            // Subfolder files: webkitRelativePath = "images/Saved/filename.jpg" (3+ segments: folder + subfolder + filename)
            // So: 2 segments = root file, 3+ segments = subfolder file
            const isInSubfolder = pathSegments.length > 2;
            
            if (index < 5) {
              console.log(`üîç [FILTER] File ${index + 1} path analysis:`, {
                relativePath: relativePath,
                pathSegments: pathSegments,
                segmentCount: pathSegments.length,
                isInSubfolder: isInSubfolder,
                filename: pathSegments[pathSegments.length - 1],
                folderName: pathSegments[0]
              });
            }
            
            if (isInSubfolder) {
              subfolderFiles++;
              if (index < 5) {
                console.log(`üîç [FILTER] File ${index + 1} rejected: in subfolder (includeSubfolders=false) - path has ${pathSegments.length} segment(s):`, pathSegments);
              }
              return false; // File is in a subfolder
            } else {
              rootFiles++;
              filteredRootFiles++;
              if (index < 5) {
                console.log(`üîç [FILTER] File ${index + 1} accepted: root file - path has ${pathSegments.length} segment(s): "${relativePath}"`);
              }
            }
          } else if (includeSubfolders) {
            // If including subfolders, count all files
            // 2 segments = root file, 3+ segments = subfolder file
            if (file.webkitRelativePath) {
              const segmentCount = file.webkitRelativePath.split('/').length;
              if (segmentCount > 2) {
                subfolderFiles++;
                filteredSubfolderFiles++;
              } else {
                rootFiles++;
                filteredRootFiles++;
              }
            } else {
              rootFiles++;
              filteredRootFiles++;
            }
          } else {
            // No webkitRelativePath (shouldn't happen with webkitdirectory, but handle it)
            rootFiles++;
            filteredRootFiles++;
          }
          
          return true;
        });
        
        console.log('üîç [FILTER] Filtering complete:', {
          totalFiles: totalFiles,
          filteredCount: filtered.length,
          rootFiles: rootFiles,
          subfolderFiles: subfolderFiles,
          nonImageFiles: nonImageFiles,
          filteredRootFiles: filteredRootFiles,
          filteredSubfolderFiles: filteredSubfolderFiles,
          includeSubfolders: includeSubfolders
        });
        
        return filtered;
      }

    // Helper function to update red shading on file input textboxes
    // This function manages the red shading based on whether the textbox is empty
    function updateFileInputShading(element, isEmpty) {
      if (!element) return;
      if (isEmpty || !element.value || element.value.trim() === '') {
        // Apply red shading when empty
        element.style.setProperty('background-color', 'rgba(255, 0, 0, 0.1)', 'important');
        element.style.setProperty('border-color', 'rgba(255, 0, 0, 0.3)', 'important');
      } else {
        // Remove red shading when has value
        element.style.setProperty('background-color', '', 'important');
        element.style.setProperty('border-color', '', 'important');
      }
    }

    function initUI() {
      try {
        logToConsole('[INIT] Starting initUI()...', 'info');
        let config = loadConfig();
        logToConsole(`[INIT] Config loaded: ${Object.keys(config).length} keys`, 'info');
        config = normalizePathDefaults(config);
        logToConsole('[INIT] Path defaults normalized', 'info');

      // Populate ALL fields from config first
      for (const key in config) {
        const el = document.getElementById(key);
        if (el) {
          el.value = config[key];
        }
      }

        // Now clear ONLY the 4 file input textboxes - user must load files each time
        // Red shading on textboxes indicates files need to be loaded
        // This happens AFTER all other fields are populated
        const existingListInput = document.getElementById('existing_list');
        const csvOutInput = document.getElementById('csv_out');
        const referenceItemsDisplay = document.getElementById('reference_items_display');
        const saveDirInput = document.getElementById('save_dir');
        
        // Only clear these 4 specific fields - nothing else
        if (existingListInput) {
          existingListInput.value = '';
          updateFileInputShading(existingListInput, true);
        }
        if (csvOutInput) {
          csvOutInput.value = '';
          updateFileInputShading(csvOutInput, true);
        }
        if (referenceItemsDisplay) {
          referenceItemsDisplay.value = '';
          updateFileInputShading(referenceItemsDisplay, true);
        }
        if (saveDirInput) {
          saveDirInput.value = '';
          updateFileInputShading(saveDirInput, true);
        }
      
        logToConsole('[INIT] File input textboxes cleared and shaded', 'info');
        logToConsole('[INIT] initUI() completed successfully', 'success');
      } catch (error) {
        logToConsole(`[INIT] ERROR in initUI(): ${error.message}`, 'error');
        logToConsole(`[INIT] Stack trace: ${error.stack}`, 'error');
        console.error('initUI error:', error);
        throw error; // Re-throw to be caught by outer try-catch
      }
      
      // Function to update image preview
      function updateImagePreview() {
        console.log('üìã [PREVIEW] updateImagePreview() called');
        
        const dirInput = document.getElementById('save_dir_file');
        const previewContainer = document.getElementById('imagePreviewContainer');
        const previewList = document.getElementById('imagePreviewList');
        const imageCount = document.getElementById('imageCount');
        
        console.log('üìã [PREVIEW] Elements found:', {
          dirInput: !!dirInput,
          previewContainer: !!previewContainer,
          previewList: !!previewList,
          imageCount: !!imageCount,
          filesCount: dirInput && dirInput.files ? dirInput.files.length : 0
        });
        
        if (!dirInput || !dirInput.files || dirInput.files.length === 0) {
          console.log('üìã [PREVIEW] No files selected, hiding preview');
          if (previewContainer) {
            previewContainer.style.display = 'none';
          }
          return;
        }
        
        const includeSubfoldersCheckbox = document.getElementById('include_subfolders');
        const includeSubfolders = includeSubfoldersCheckbox ? includeSubfoldersCheckbox.checked : false;
        
        console.log('üìã [PREVIEW] Checkbox state:', {
          checkboxExists: !!includeSubfoldersCheckbox,
          checked: includeSubfolders
        });
        
        console.log('üìã [PREVIEW] Calling filterImageFiles with', dirInput.files.length, 'files');
        const imageFiles = filterImageFiles(dirInput.files, includeSubfolders);
        
        if (!previewContainer || !previewList || !imageCount) {
          console.error('üìã [PREVIEW] ERROR: Preview elements not found');
          return;
        }
        
        if (imageFiles.length === 0) {
          console.log('üìã [PREVIEW] No image files after filtering, hiding preview');
          previewContainer.style.display = 'none';
          return;
        }
        
        // Show preview
        console.log('üìã [PREVIEW] Showing preview with', imageFiles.length, 'images');
        previewContainer.style.display = 'block';
        previewContainer.style.visibility = 'visible';
        imageCount.textContent = imageFiles.length;
        
        // Initialize selection state - all checked by default
        if (!window.imageSelectionState) {
          window.imageSelectionState = {};
        }
        
        // Reset selection state for new files (all checked by default)
        imageFiles.forEach(file => {
          const fileKey = file.webkitRelativePath || file.name;
          if (window.imageSelectionState[fileKey] === undefined) {
            window.imageSelectionState[fileKey] = true; // Default checked
          }
        });
        
        // Update selected count
        updateSelectedCount();
        
        // Scroll preview into view
        previewContainer.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        
        // Prevent multiple simultaneous updates
        if (window.updatingPreview) {
          console.log('‚è∏Ô∏è [PREVIEW] Update already in progress, skipping...');
          return;
        }
        window.updatingPreview = true;
        
        // Auto-clear the flag after a reasonable timeout (2 seconds) as safety
        setTimeout(() => {
          if (window.updatingPreview) {
            console.log('‚ö†Ô∏è [PREVIEW] Update flag stuck, clearing it');
            window.updatingPreview = false;
          }
        }, 2000);
        
        // Build gallery view with thumbnails
        previewList.innerHTML = ''; // Clear first
        console.log('üßπ [GALLERY] Cleared preview list, starting to add', imageFiles.length, 'items');
        
        // Helper function to extract subfolder from path
        function getSubfolder(relativePath) {
          const parts = relativePath.split('/');
          if (parts.length > 2) {
            // Skip the first part (selected folder name) and last part (filename)
            return parts.slice(1, -1).join('/');
          }
          return null;
        }
        
        // Helper function to get just the filename
        function getFilename(relativePath) {
          const parts = relativePath.split('/');
          return parts[parts.length - 1];
        }
        
        // Create gallery items
        console.log('üé® [GALLERY] Starting to create', imageFiles.length, 'gallery items');
        let itemsCreated = 0;
        imageFiles.forEach((file, index) => {
          try {
            console.log(`üé® [GALLERY] Processing item ${index + 1}/${imageFiles.length}:`, file.name);
          const relativePath = file.webkitRelativePath || file.name;
          const fileKey = relativePath;
          const isChecked = window.imageSelectionState[fileKey] !== false; // Default true
          const itemId = `gallery_item_${index}`;
          const thumbnailId = `gallery_thumb_${index}`;
          const filename = getFilename(relativePath);
          const subfolder = getSubfolder(relativePath);
          
          // Create gallery item container
          const itemDiv = document.createElement('div');
          itemDiv.id = itemId;
          itemDiv.className = `gallery-item ${isChecked ? 'selected' : ''}`;
          itemDiv.setAttribute('data-file-key', fileKey);
          
          // Create thumbnail image
          const img = document.createElement('img');
          img.id = thumbnailId;
          img.className = 'gallery-thumbnail loading';
          img.alt = filename;
          // Don't use lazy loading for thumbnails in scrollable container - load immediately
          // img.loading = 'lazy';
          
          // Create object URL for the image
          try {
            const objectURL = URL.createObjectURL(file);
            console.log('üñºÔ∏è [GALLERY] Created object URL for:', filename);
            
            // Handle image load
            img.onload = function() {
              this.classList.remove('loading');
              console.log('‚úÖ [GALLERY] Image loaded successfully:', filename);
            };
            
            // Handle image load errors
            img.onerror = function() {
              console.error('‚ùå [GALLERY] Failed to load image:', filename, 'URL:', this.src);
              this.classList.remove('loading');
              // Show placeholder or error indicator
              this.style.background = 'var(--card-bg)';
              this.style.display = 'flex';
              this.style.alignItems = 'center';
              this.style.justifyContent = 'center';
              this.style.color = 'var(--text)';
              this.style.fontSize = '2em';
              this.textContent = 'üñºÔ∏è';
              this.alt = 'Failed to load: ' + filename;
            };
            
            // Set the src to trigger loading
            img.src = objectURL;
            
            // Debug: Check if image is in DOM and visible
            setTimeout(() => {
              console.log('üîç [GALLERY] Image check for:', filename, {
                inDOM: document.body.contains(img),
                src: img.src.substring(0, 50),
                complete: img.complete,
                naturalWidth: img.naturalWidth,
                naturalHeight: img.naturalHeight
              });
            }, 100);
          } catch (error) {
            console.error('‚ùå [GALLERY] Error creating object URL for:', filename, error);
            img.onerror();
          }
          
          // Create info section
          const infoDiv = document.createElement('div');
          infoDiv.className = 'gallery-info';
          
          const filenameDiv = document.createElement('div');
          filenameDiv.className = 'gallery-filename';
          filenameDiv.textContent = filename;
          
          infoDiv.appendChild(filenameDiv);
          
          if (subfolder) {
            const subfolderDiv = document.createElement('div');
            subfolderDiv.className = 'gallery-subfolder';
            subfolderDiv.textContent = `üìÅ ${subfolder}`;
            infoDiv.appendChild(subfolderDiv);
          }
          
          // Assemble item
          itemDiv.appendChild(img);
          itemDiv.appendChild(infoDiv);
          
          // Add click handler to toggle selection
          itemDiv.addEventListener('click', (e) => {
            // Allow clicking anywhere on the item to toggle
            const currentState = window.imageSelectionState[fileKey] !== false;
            const newState = !currentState;
            window.imageSelectionState[fileKey] = newState;
            
            // Update visual state
            if (newState) {
              itemDiv.classList.add('selected');
            } else {
              itemDiv.classList.remove('selected');
            }
            
            updateSelectedCount();
          });
          
          // Add to preview list
          previewList.appendChild(itemDiv);
          
          // Debug: Log each item being added
          console.log('üì¶ [GALLERY] Added gallery item:', {
            index: index,
            filename: filename,
            itemId: itemId,
            inDOM: document.body.contains(itemDiv),
            parent: itemDiv.parentElement?.id,
            itemWidth: itemDiv.offsetWidth,
            itemHeight: itemDiv.offsetHeight
          });
          
          // Store object URL for cleanup later
          if (!window.imageObjectURLs) {
            window.imageObjectURLs = [];
          }
          window.imageObjectURLs.push({ url: objectURL, fileKey: fileKey });
          
          itemsCreated++;
          console.log(`‚úÖ [GALLERY] Successfully created item ${index + 1}/${imageFiles.length} (${itemsCreated} total created so far)`);
          } catch (error) {
            console.error(`‚ùå [GALLERY] Error creating item ${index + 1}:`, error, file.name);
          }
        });
        
        console.log(`üéØ [GALLERY] forEach loop completed. Created ${itemsCreated} items out of ${imageFiles.length} total`);
        
        // Debug: Log final gallery state after a brief delay to allow rendering
        setTimeout(() => {
          console.log('üé® [GALLERY] Gallery populated:', {
            totalItems: imageFiles.length,
            domItems: previewList.children.length,
            gridStyle: window.getComputedStyle(previewList).display,
            gridColumns: window.getComputedStyle(previewList).gridTemplateColumns,
            containerWidth: previewList.offsetWidth,
            firstItemWidth: previewList.children[0]?.offsetWidth,
            firstItemPosition: previewList.children[0] ? window.getComputedStyle(previewList.children[0]).position : 'N/A'
          });
          
          // Log positions of first few items to check for overlap
          Array.from(previewList.children).slice(0, 3).forEach((item, idx) => {
            const rect = item.getBoundingClientRect();
            console.log(`üìç [GALLERY] Item ${idx} position:`, {
              left: rect.left,
              top: rect.top,
              width: rect.width,
              height: rect.height
            });
          });
        }, 200);
        
        // Cleanup old object URLs when preview is updated
        if (window.imageObjectURLs) {
          window.imageObjectURLs.forEach(item => {
            URL.revokeObjectURL(item.url);
          });
          window.imageObjectURLs = [];
        }
        
        // Clear the updating flag now that we're done
        window.updatingPreview = false;
        console.log('‚úÖ [PREVIEW] Preview update completed, flag cleared');
        
        console.log('üìã [PREVIEW] Preview updated successfully:', {
          imageCount: imageFiles.length,
          previewVisible: previewContainer.style.display,
          domItems: previewList.children.length
        });
      }
      
      // Function to update selected count display
      function updateSelectedCount() {
        const selectedCountEl = document.getElementById('selectedCount');
        if (!selectedCountEl || !window.imageSelectionState) return;
        
        const dirInput = document.getElementById('save_dir_file');
        if (!dirInput || !dirInput.files || dirInput.files.length === 0) {
          selectedCountEl.textContent = '0';
          return;
        }
        
        const includeSubfoldersCheckbox = document.getElementById('include_subfolders');
        const includeSubfolders = includeSubfoldersCheckbox ? includeSubfoldersCheckbox.checked : false;
        const imageFiles = filterImageFiles(dirInput.files, includeSubfolders);
        
        let selectedCount = 0;
        imageFiles.forEach(file => {
          const fileKey = file.webkitRelativePath || file.name;
          if (window.imageSelectionState[fileKey] !== false) {
            selectedCount++;
          }
        });
        
        selectedCountEl.textContent = selectedCount;
      }
      
      // Select All / Deselect All functions
      function selectAllImages() {
        const dirInput = document.getElementById('save_dir_file');
        if (!dirInput || !dirInput.files || !window.imageSelectionState) return;
        
        const includeSubfoldersCheckbox = document.getElementById('include_subfolders');
        const includeSubfolders = includeSubfoldersCheckbox ? includeSubfoldersCheckbox.checked : false;
        const imageFiles = filterImageFiles(dirInput.files, includeSubfolders);
        
        imageFiles.forEach((file) => {
          const fileKey = file.webkitRelativePath || file.name;
          window.imageSelectionState[fileKey] = true;
          
          // Update gallery item visual state by finding item with matching data attribute
          const previewList = document.getElementById('imagePreviewList');
          if (previewList) {
            const itemDiv = previewList.querySelector(`[data-file-key="${fileKey}"]`);
            if (itemDiv) {
              itemDiv.classList.add('selected');
            }
          }
        });
        
        updateSelectedCount();
      }
      
      function deselectAllImages() {
        const dirInput = document.getElementById('save_dir_file');
        if (!dirInput || !dirInput.files || !window.imageSelectionState) return;
        
        const includeSubfoldersCheckbox = document.getElementById('include_subfolders');
        const includeSubfolders = includeSubfoldersCheckbox ? includeSubfoldersCheckbox.checked : false;
        const imageFiles = filterImageFiles(dirInput.files, includeSubfolders);
        
        imageFiles.forEach((file) => {
          const fileKey = file.webkitRelativePath || file.name;
          window.imageSelectionState[fileKey] = false;
          
          // Update gallery item visual state by finding item with matching data attribute
          const previewList = document.getElementById('imagePreviewList');
          if (previewList) {
            const itemDiv = previewList.querySelector(`[data-file-key="${fileKey}"]`);
            if (itemDiv) {
              itemDiv.classList.remove('selected');
            }
          }
        });
        
        updateSelectedCount();
      }
      
      // Handle directory selection - use both change and input events for maximum compatibility
      const dirInput = document.getElementById('save_dir_file');
      
      // Store previous file count to detect changes
      let previousFileCount = 0;
      
      function handleDirectorySelection(e) {
        console.log('üìÅ [DIRECTORY] Directory selection event fired');
        console.log('üìÅ [DIRECTORY] Event type:', e.type);
        console.log('üìÅ [DIRECTORY] Target:', e.target);
        
        const target = e.target || dirInput;
        const files = target.files;
        const filesLength = files ? files.length : 0;
        
        console.log('üìÅ [DIRECTORY] Files selected:', filesLength);
        console.log('üìÅ [DIRECTORY] Files object:', files);
        console.log('üìÅ [DIRECTORY] Input element:', {
          id: target.id,
          type: target.type,
          hasWebkitDirectory: target.hasAttribute('webkitdirectory'),
          hasDirectory: target.hasAttribute('directory')
        });
        
        // Small delay to ensure files are fully loaded
        setTimeout(() => {
          const filesAfterDelay = target.files;
          const filesLengthAfterDelay = filesAfterDelay ? filesAfterDelay.length : 0;
          
          console.log('üìÅ [DIRECTORY] Files after delay:', filesLengthAfterDelay);
          
          if (!filesAfterDelay || filesLengthAfterDelay === 0) {
            console.log('üìÅ [DIRECTORY] No files selected, updating preview');
            // User cancelled or no files selected - apply red shading
            const saveDirInput = document.getElementById('save_dir');
            if (saveDirInput) {
              saveDirInput.value = '';
              updateFileInputShading(saveDirInput, true);
            }
            updateImagePreview();
            return;
          }
          
          console.log('üìÅ [DIRECTORY] Processing', filesLengthAfterDelay, 'files');
          
          const firstFile = filesAfterDelay[0];
          console.log('üìÅ [DIRECTORY] First file info:', {
            name: firstFile.name,
            webkitRelativePath: firstFile.webkitRelativePath || '(none)',
            size: firstFile.size,
            type: firstFile.type
          });
          
          // Log a few more files to understand the path structure
          console.log('üìÅ [DIRECTORY] Sample file paths (first 5):');
          for (let i = 0; i < Math.min(5, filesAfterDelay.length); i++) {
            const file = filesAfterDelay[i];
            const pathParts = file.webkitRelativePath ? file.webkitRelativePath.split('/') : [];
            console.log(`  File ${i + 1}: "${file.webkitRelativePath}" ‚Üí ${pathParts.length} segment(s):`, pathParts);
          }
          
          let dirPath = '';
          if (firstFile.webkitRelativePath) {
            // Extract directory path from webkitRelativePath
            // For root files: webkitRelativePath = "filename.jpg", dirPath = ""
            // For subfolder files: webkitRelativePath = "subfolder/filename.jpg", dirPath = "subfolder"
            // NOTE: When selecting a folder, webkitRelativePath might include the folder name itself
            const parts = firstFile.webkitRelativePath.split('/');
            console.log('üìÅ [DIRECTORY] Path parts:', parts);
            console.log('üìÅ [DIRECTORY] Path analysis:', {
              fullPath: firstFile.webkitRelativePath,
              parts: parts,
              partCount: parts.length,
              filename: parts[parts.length - 1],
              isRootFile: parts.length === 1
            });
            
            if (parts.length > 1) {
              parts.pop(); // Remove filename
            dirPath = parts.join('/');
            }
          } else if (firstFile.path) {
            const parts = firstFile.path.split(/[/\\]/);
            parts.pop();
            dirPath = parts.join('/');
          }
          
          const saveDirInput = document.getElementById('save_dir');
          if (saveDirInput) {
            if (dirPath) {
              saveDirInput.value = dirPath;
              console.log('üìÅ [DIRECTORY] Set directory path to:', dirPath);
            } else {
              // Root directory selected
              saveDirInput.value = 'Root';
              console.log('üìÅ [DIRECTORY] Root directory selected');
            }
            // Remove red shading when directory is successfully selected
            updateFileInputShading(saveDirInput, false);
          }
          
          // Always update preview when directory changes
          console.log('üìÅ [DIRECTORY] Calling updateImagePreview() with', files.length, 'files');
          updateImagePreview();
        }, 100);
      }
      
      // Listen to both change and input events
      dirInput.addEventListener('change', (e) => {
        console.log('üìÅ [DIRECTORY] ‚ö° CHANGE EVENT FIRED!');
        console.log('üìÅ [DIRECTORY] Change event details:', {
          type: e.type,
          target: e.target,
          filesCount: e.target.files ? e.target.files.length : 0,
          timestamp: new Date().toISOString()
        });
        handleDirectorySelection(e);
      });
      
      dirInput.addEventListener('input', (e) => {
        console.log('üìÅ [DIRECTORY] ‚ö° INPUT EVENT FIRED!');
        console.log('üìÅ [DIRECTORY] Input event details:', {
          type: e.type,
          target: e.target,
          filesCount: e.target.files ? e.target.files.length : 0,
          timestamp: new Date().toISOString()
        });
        handleDirectorySelection(e);
      });
      
      // Also listen for any other file-related events
      ['focus', 'blur'].forEach(eventType => {
        dirInput.addEventListener(eventType, (e) => {
          console.log(`üìÅ [DIRECTORY] Input ${eventType} event:`, {
            filesCount: e.target.files ? e.target.files.length : 0
          });
        });
      });
      
      // Track when dialog opens/closes - this is key for Windows folder picker
      let dialogOpen = false;
      let focusCheckTimeouts = [];
      
      // Track when window loses focus (dialog opens)
      window.addEventListener('blur', () => {
        console.log('üìÅ [DIRECTORY] Window lost focus - dialog likely opened');
        dialogOpen = true;
      });
      
      // Check when window regains focus (native dialog closes)
      window.addEventListener('focus', () => {
        console.log('üìÅ [DIRECTORY] Window regained focus - dialog likely closed');
        
        // Clear any existing timeouts
        focusCheckTimeouts.forEach(clearTimeout);
        focusCheckTimeouts = [];
        
        if (dialogOpen) {
          dialogOpen = false;
          
          // Check multiple times with increasing delays to catch files being set
          [50, 100, 200, 300, 500, 750, 1000, 1500, 2000].forEach((delay, index) => {
            const timeout = setTimeout(() => {
              const currentCount = dirInput.files ? dirInput.files.length : 0;
              console.log(`üìÅ [DIRECTORY] Focus check ${index + 1} (${delay}ms):`, currentCount, 'files');
              
              if (currentCount > 0 && currentCount !== previousFileCount) {
                console.log('üìÅ [DIRECTORY] Files detected after focus!', currentCount);
                previousFileCount = currentCount;
                handleDirectorySelection({ type: 'focus', target: dirInput });
                // Clear remaining timeouts since we found the files
                focusCheckTimeouts.forEach(clearTimeout);
                focusCheckTimeouts = [];
              }
            }, delay);
            focusCheckTimeouts.push(timeout);
          });
        }
      });
      
      // Also check when page becomes visible again (handles tab switching)
      document.addEventListener('visibilitychange', () => {
        if (!document.hidden && dialogOpen) {
          console.log('üìÅ [DIRECTORY] Page became visible - checking for files');
          setTimeout(() => {
            const currentCount = dirInput.files ? dirInput.files.length : 0;
            if (currentCount > 0 && currentCount !== previousFileCount) {
              console.log('üìÅ [DIRECTORY] Files detected after visibility change!', currentCount);
              previousFileCount = currentCount;
              handleDirectorySelection({ type: 'visibility', target: dirInput });
            }
          }, 200);
        }
      });
      
      // Track when directory picker is opened - use ID selector for reliability
      const chooseDirBtn = document.getElementById('chooseDirBtn');
      if (chooseDirBtn) {
        chooseDirBtn.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          console.log('üìÅ [DIRECTORY] Choose Directory button clicked - opening native dialog');
          checkingFiles = true;
          previousFileCount = dirInput.files ? dirInput.files.length : 0;
          console.log('üìÅ [DIRECTORY] Current file count before selection:', previousFileCount);
          
          // Trigger the file input click
          dirInput.click();
          
          // Set up aggressive polling right after click (before dialog even closes)
          const pollDelays = [500, 1000, 1500, 2000, 2500, 3000];
          pollDelays.forEach((delay, index) => {
            setTimeout(() => {
              const currentCount = dirInput.files ? dirInput.files.length : 0;
              console.log(`üìÅ [DIRECTORY] Post-click check ${index + 1} (${delay}ms):`, currentCount, 'files');
              if (currentCount > 0 && currentCount !== previousFileCount) {
                console.log('üìÅ [DIRECTORY] Files detected in post-click check!', currentCount);
                previousFileCount = currentCount;
                handleDirectorySelection({ type: 'post-click', target: dirInput });
              }
            }, delay);
          });
        });
      } else {
        console.error('üìÅ [DIRECTORY] Choose Directory button not found!');
      }
      
      // Also check periodically if files were added (fallback for some browsers)
      const pollInterval = setInterval(() => {
        const currentCount = dirInput.files ? dirInput.files.length : 0;
        if (currentCount !== previousFileCount && currentCount > 0) {
          console.log('üìÅ [DIRECTORY] File count changed via polling:', currentCount, '(was', previousFileCount, ')');
          previousFileCount = currentCount;
          handleDirectorySelection({ type: 'polling', target: dirInput });
        }
      }, 1000);
      
      // Expose a manual check function for debugging
      window.checkDirectoryFiles = function() {
        console.log('üìÅ [DIRECTORY] Manual check triggered');
        console.log('üìÅ [DIRECTORY] Input element:', dirInput);
        console.log('üìÅ [DIRECTORY] Input.files:', dirInput.files);
        console.log('üìÅ [DIRECTORY] Input.files.length:', dirInput.files ? dirInput.files.length : 'N/A');
        console.log('üìÅ [DIRECTORY] Input.files is FileList?', dirInput.files instanceof FileList);
        
        const currentCount = dirInput.files ? dirInput.files.length : 0;
        console.log('üìÅ [DIRECTORY] Current file count:', currentCount);
        console.log('üìÅ [DIRECTORY] Previous file count:', previousFileCount);
        
        if (dirInput.files && dirInput.files.length > 0) {
          console.log('üìÅ [DIRECTORY] First file:', {
            name: dirInput.files[0].name,
            webkitRelativePath: dirInput.files[0].webkitRelativePath,
            size: dirInput.files[0].size
          });
        }
        
        if (currentCount > 0) {
          console.log('üìÅ [DIRECTORY] Files found! Triggering handler...');
          previousFileCount = currentCount;
          handleDirectorySelection({ type: 'manual', target: dirInput });
        } else {
          console.log('üìÅ [DIRECTORY] No files found in input element');
          console.log('üìÅ [DIRECTORY] Possible reasons:');
          console.log('  - Dialog was cancelled');
          console.log('  - No folder was selected');
          console.log('  - Browser security restriction');
          console.log('  - webkitdirectory not supported');
        }
      };
      
      console.log('üìÅ [DIRECTORY] Directory selection handler initialized. Use checkDirectoryFiles() in console to manually check.');
      
      // Update preview when subfolders checkbox changes
      document.getElementById('include_subfolders').addEventListener('change', (e) => {
        console.log('‚òëÔ∏è [CHECKBOX] Include subfolders changed:', e.target.checked);
        updateImagePreview();
        updateSelectedCount();
      });
      
      // Select All / Deselect All button handlers
      const selectAllBtn = document.getElementById('selectAllImages');
      const deselectAllBtn = document.getElementById('deselectAllImages');
      if (selectAllBtn) {
        selectAllBtn.addEventListener('click', selectAllImages);
      }
      if (deselectAllBtn) {
        deselectAllBtn.addEventListener('click', deselectAllImages);
      }

      // CSV Output file picker button
      const csvOutLoadBtn = document.getElementById('csvOutLoadBtn');
      if (csvOutLoadBtn) {
        csvOutLoadBtn.addEventListener('click', () => {
          document.getElementById('csv_out_file').click();
        });
      }

      document.getElementById('csv_out_file').addEventListener('change', async (e) => {
        if (!e.target.files.length) {
          const csvOutInput = document.getElementById('csv_out');
          csvOutInput.value = '';
          updateFileInputShading(csvOutInput, true);
          setCsvOutStatus('');
          loadedCsvData = null; // Clear loaded CSV data
          localStorage.removeItem('item_gen_csv_out_filename');
          return;
        }
        const file = e.target.files[0];
        
        // Validate CSV file format
        const validation = await validateCsvFile(file);
        
        if (!validation.valid) {
          // Show error message
          setCsvOutStatus('');
          const csvOutInput = document.getElementById('csv_out');
          csvOutInput.value = '';
          // Restore red shading to indicate file needs to be loaded
          updateFileInputShading(csvOutInput, true);
          // Clear BOTH loaded CSV data AND downloaded CSV data to force user to reload or download again
          loadedCsvData = null;
          csvData = null;
          e.target.value = '';
          alert(`Invalid CSV file format: ${validation.error}`);
          return;
        }

        // File is valid, parse and store CSV data
        const csvOutInput = document.getElementById('csv_out');
        const fileName = file.name;
        // Try to get folder path - browsers don't expose full path, but we can show folder\filename format
        let displayPath = fileName;
        if (file.webkitRelativePath) {
          // If file has relative path, use it
          const pathParts = file.webkitRelativePath.split('/');
          if (pathParts.length > 1) {
            displayPath = pathParts.slice(0, -1).join('\\') + '\\' + pathParts[pathParts.length - 1];
          }
        }
        csvOutInput.value = displayPath;
        csvOutInput.title = fileName; // Tooltip shows filename on hover
        // Remove red shading when file is loaded
        updateFileInputShading(csvOutInput, false);
        setCsvOutStatus(`${validation.rowCount} rows loaded`);
        
        // Parse CSV data from file
        try {
          if (file.name.toLowerCase().endsWith('.csv')) {
            const text = await file.text();
            loadedCsvData = parseCsvToArray(text);
          } else {
            // Excel file - convert to CSV format
            const buffer = await file.arrayBuffer();
            const workbook = XLSX.read(buffer, { type: 'array' });
            const sheetName = workbook.SheetNames[0];
            const sheet = workbook.Sheets[sheetName];
            const rows = XLSX.utils.sheet_to_json(sheet, { header: 1, defval: '' });
            // Convert to same format as parseCsvToArray (skip header, split by comma)
            loadedCsvData = rows.slice(1).map(row => {
              if (Array.isArray(row)) {
                return row.map(cell => String(cell || '').trim());
              }
              return [];
            }).filter(row => row.length > 0 && row.some(cell => cell.length > 0));
          }
          
          // Clear csvData when a new CSV is successfully loaded manually
          // This ensures manually loaded CSV takes priority over downloaded CSV
          csvData = null;
        } catch (error) {
          console.error('Error parsing CSV file:', error);
          setCsvOutStatus('');
          alert(`Error parsing file: ${error.message || 'Failed to parse file. Please ensure the file is a valid CSV or Excel file.'}`);
          csvOutInput.value = '';
          updateFileInputShading(csvOutInput, true);
          // Clear BOTH loaded CSV data AND downloaded CSV data to force user to reload or download again
          loadedCsvData = null;
          csvData = null;
          e.target.value = '';
          return;
        }
        
        // Store filename in localStorage for persistence
        localStorage.setItem('item_gen_csv_out_filename', fileName);
        e.target.value = '';
      });

      // Reference Items file picker button
      const referenceItemsLoadBtn = document.getElementById('referenceItemsLoadBtn');
      const referenceItemsFileInput = document.getElementById('item_numbers_csv');
      const referenceItemsDisplayEl = document.getElementById('reference_items_display');
      
      if (referenceItemsLoadBtn && referenceItemsFileInput) {
        referenceItemsLoadBtn.addEventListener('click', () => {
          referenceItemsFileInput.click();
        });
      }
      
      referenceItemsFileInput.addEventListener('change', async (e) => {
        if (!e.target.files.length) {
          referenceItems = [];
          setItemNumbersStatus('');
          if (referenceItemsDisplayEl) {
            referenceItemsDisplayEl.value = '';
            updateFileInputShading(referenceItemsDisplayEl, true);
          }
          // Clear stored filename
          localStorage.removeItem('item_gen_reference_items_filename');
          return;
        }
        const file = e.target.files[0];
        const fileName = file.name;
        
        // Validate file format before loading
        const validation = await validateReferenceItemsFile(file);
        
        if (!validation.valid) {
          // Show error message
          setItemNumbersStatus('');
          
          if (referenceItemsDisplayEl) {
            referenceItemsDisplayEl.value = '';
            referenceItemsDisplayEl.removeAttribute('title');
            // Restore red shading to indicate file needs to be loaded
            updateFileInputShading(referenceItemsDisplayEl, true);
          }
          
          // Clear reference items data to force user to reload
          referenceItems = [];
          localStorage.removeItem('item_gen_reference_items_filename');
          e.target.value = '';
          alert(`Invalid file format: ${validation.error}`);
          return;
        }
        
        // File is valid, parse and store CSV data
        try {
          const parseResult = await parseReferenceItemsFile(file);
          referenceItems = parseResult.items;
          const headerDetected = parseResult.headerDetected;
          
          // Update display textbox - show only filename (full path not available for security)
          if (referenceItemsDisplayEl) {
            // Try to get folder path - browsers don't expose full path, but we can show folder\filename format
            let displayPath = fileName;
            if (file.webkitRelativePath) {
              // If file has relative path, use it
              const pathParts = file.webkitRelativePath.split('/');
              if (pathParts.length > 1) {
                displayPath = pathParts.slice(0, -1).join('\\') + '\\' + pathParts[pathParts.length - 1];
              }
            }
            referenceItemsDisplayEl.value = displayPath;
            referenceItemsDisplayEl.title = fileName; // Tooltip shows filename on hover
            // Remove red shading when file is loaded
            updateFileInputShading(referenceItemsDisplayEl, false);
          }
          
          // Store filename only after successful parse
          localStorage.setItem('item_gen_reference_items_filename', fileName);
          
          // Use validation count if available, otherwise use parsed items count
          const itemCount = validation.itemCount || referenceItems.length;
          const statusMessage = itemCount > 0
            ? headerDetected
              ? `${itemCount} reference items loaded (header row detected and skipped)`
              : `${itemCount} reference items loaded`
            : 'No item IDs detected in the first column.';
          setItemNumbersStatus(statusMessage);
        } catch (error) {
          // File parsing failed - show error and restore red shading
          console.error('Error parsing reference items file:', error);
          setItemNumbersStatus('');
          
          if (referenceItemsDisplayEl) {
            referenceItemsDisplayEl.value = '';
            referenceItemsDisplayEl.removeAttribute('title');
            // Restore red shading to indicate file needs to be loaded
            updateFileInputShading(referenceItemsDisplayEl, true);
          }
          
          // Clear reference items data to force user to reload
          referenceItems = [];
          localStorage.removeItem('item_gen_reference_items_filename');
          e.target.value = '';
          alert(`Error loading file: ${error.message || 'Failed to parse file. Please ensure the file is a valid CSV or Excel file.'}`);
        }
      });
      
      // NOTE: Existing Item List Load button and file change handler are now in registerEventHandlers()

      // Current Item List section removed - no initialization needed
      setItemList([], 'No items loaded yet.');
    }

    async function parseReferenceItemsFile(file) {
      const extension = file.name.split('.').pop().toLowerCase();
      let items = [];
      let headerDetected = false;
      let isFirstRow = true;
      
      if (extension === 'csv' || extension === 'txt') {
        const text = await file.text();
        const lines = text.split(/\r?\n/);
        lines.forEach((line, index) => {
          const value = line.split(',')[0].trim();
          // Check if first row is a header (first cell is "ItemId")
          if (isFirstRow && value && value.toLowerCase() === 'itemid') {
            headerDetected = true;
            isFirstRow = false;
            return; // Skip header row
          }
          isFirstRow = false;
          if (value) items.push(value);
        });
      } else {
        const buffer = await file.arrayBuffer();
        const workbook = XLSX.read(buffer, { type: 'array' });
        const sheetName = workbook.SheetNames[0];
        const sheet = workbook.Sheets[sheetName];
        const rows = XLSX.utils.sheet_to_json(sheet, { header: 1 });
        rows.forEach((row, index) => {
          const value = row && row[0] ? String(row[0]).trim() : '';
          // Check if first row is a header (first cell is "ItemId")
          if (isFirstRow && value && value.toLowerCase() === 'itemid') {
            headerDetected = true;
            isFirstRow = false;
            return; // Skip header row
          }
          isFirstRow = false;
          if (value) items.push(value);
        });
      }
      return { items, headerDetected };
    }

    function normalizeItemList(items) {
      const seen = new Set();
      const normalized = [];
      items.forEach(item => {
        const trimmed = item.trim();
        if (!trimmed) return;
        const key = trimmed.toLowerCase();
        if (!seen.has(key)) {
          seen.add(key);
          normalized.push(trimmed);
        }
      });
      return normalized;
    }



    function setItemList(items, statusMessage, autoApply = false) {
      currentItemList = normalizeItemList(items || []);
      
      // Display status messages in genStatus area (Generate Items section)
      const genStatusEl = document.getElementById('genStatus');
      if (genStatusEl) {
        if (statusMessage) {
          genStatusEl.textContent = statusMessage;
        } else {
          // Default message if no specific message provided
          genStatusEl.textContent = currentItemList.length ? `${currentItemList.length} items in list` : 'No items loaded yet.';
        }
      }
    }

    async function loadItemsFromTextFile(file) {
      // This function is now primarily used for programmatic loading
      // The file validation and loading is handled in the change event listener
      if (!file) return;
      const text = await file.text();
      const items = text.split(/\r?\n/).map(line => line.trim()).filter(Boolean);
      // Auto-apply when loading from file - no warnings, display in white
      setItemList(items, `${items.length} items loaded from ${file.name}`, true);
      setExistingListStatus(`${items.length} items loaded`);
    }


    function logToConsole(message, type = 'info') {
      const consoleEl = document.getElementById('console');
      const timestamp = new Date().toLocaleTimeString();
      const className = type === 'error' ? 'error' : type === 'success' ? 'success' : type === 'warning' ? 'warning' : 'info';
      consoleEl.innerHTML += `<span class="${className}">[${timestamp}] ${message}</span>\n`;
      consoleEl.scrollTop = consoleEl.scrollHeight;
    }

    function base64ToBlob(base64Data, mimeType) {
      const byteCharacters = atob(base64Data);
      const byteNumbers = new Array(byteCharacters.length);
      for (let i = 0; i < byteCharacters.length; i++) {
        byteNumbers[i] = byteCharacters.charCodeAt(i);
      }
      const byteArray = new Uint8Array(byteNumbers);
      return new Blob([byteArray], { type: mimeType });
    }

    function downloadBase64File(base64Data, fileName, mimeType) {
      const blob = base64ToBlob(base64Data, mimeType);
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = fileName;
      a.click();
      URL.revokeObjectURL(url);
    }

    function downloadTextFile(content, fileName) {
      const blob = new Blob([content], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = fileName;
      a.click();
      URL.revokeObjectURL(url);
    }

    function setItemNumbersStatus(text) {
      document.getElementById('itemNumbersStatus').textContent = text || '';
    }

    function setExistingListStatus(text) {
      // Display green text in the existingListStatus span (like other load textboxes)
      document.getElementById('existingListStatus').textContent = text || '';
    }

    function setCsvOutStatus(text) {
      document.getElementById('csvOutStatus').textContent = text || '';
    }

    async function validateCsvFile(file) {
      if (!file) {
        return { valid: false, error: 'No file selected' };
      }

      const extension = file.name.split('.').pop().toLowerCase();
      if (!['csv', 'xls', 'xlsx'].includes(extension)) {
        return { valid: false, error: 'File must be a CSV or Excel file (.csv, .xls, .xlsx)' };
      }

      try {
        let rows = [];
        
        if (extension === 'csv') {
          const text = await file.text();
          rows = text.split(/\r?\n/).map(line => {
            // Parse CSV line (handle quoted values)
            const result = [];
            let current = '';
            let inQuotes = false;
            for (let i = 0; i < line.length; i++) {
              const char = line[i];
              if (char === '"') {
                inQuotes = !inQuotes;
              } else if (char === ',' && !inQuotes) {
                result.push(current.trim());
                current = '';
              } else {
                current += char;
              }
            }
            result.push(current.trim());
            return result;
          }).filter(row => row.some(cell => cell.length > 0)); // Filter empty rows
        } else {
          // Excel file
          const buffer = await file.arrayBuffer();
          const workbook = XLSX.read(buffer, { type: 'array' });
          const sheetName = workbook.SheetNames[0];
          const sheet = workbook.Sheets[sheetName];
          rows = XLSX.utils.sheet_to_json(sheet, { header: 1, defval: '' });
          rows = rows.map(row => Array.isArray(row) ? row.map(cell => String(cell || '').trim()) : []);
          rows = rows.filter(row => row.some(cell => cell.length > 0)); // Filter empty rows
        }

        if (rows.length === 0) {
          return { valid: false, error: 'File is empty or contains no data rows' };
        }

        // Check if we have at least a header row and one data row
        if (rows.length < 2) {
          return { valid: false, error: 'File must contain at least one data row (excluding header)' };
        }

        // Check if we have at least 4 columns
        const maxColumns = Math.max(...rows.map(row => row.length));
        if (maxColumns < 4) {
          return { valid: false, error: `File must have at least 4 columns. Found ${maxColumns} column(s).` };
        }

        // Validate that all data rows (excluding header) have data in the first 4 columns
        const headerRow = rows[0];
        const dataRows = rows.slice(1); // All rows except header
        
        // Check each data row
        const invalidRows = [];
        dataRows.forEach((row, index) => {
          // Check if first 4 columns have data (not empty/whitespace)
          const requiredColumns = row.slice(0, 4);
          const hasEmptyColumn = requiredColumns.some((cell, colIndex) => {
            const cellValue = String(cell || '').trim();
            return cellValue.length === 0;
          });
          
          if (hasEmptyColumn) {
            invalidRows.push(index + 2); // +2 because: +1 for header, +1 for 1-based row numbering
          }
        });

        if (invalidRows.length > 0) {
          const rowList = invalidRows.length <= 5 
            ? invalidRows.join(', ')
            : `${invalidRows.slice(0, 5).join(', ')} and ${invalidRows.length - 5} more`;
          return { 
            valid: false, 
            error: `Invalid data: ${invalidRows.length} row(s) have empty values in required columns (first 4 columns). Rows with issues: ${rowList}. All rows must have data in the first 4 columns.` 
          };
        }

        // Count data rows (excluding header)
        const dataRowCount = dataRows.length;

        return { valid: true, rowCount: dataRowCount };
      } catch (error) {
        return { valid: false, error: `Error reading file: ${error.message}` };
      }
    }

    async function validateReferenceItemsFile(file) {
      if (!file) {
        return { valid: false, error: 'No file selected' };
      }

      const extension = file.name.split('.').pop().toLowerCase();
      if (!['csv', 'txt', 'xls', 'xlsx'].includes(extension)) {
        return { valid: false, error: 'File must be a CSV, TXT, or Excel file (.csv, .txt, .xls, .xlsx)' };
      }

      try {
        let rows = [];
        
        if (extension === 'csv' || extension === 'txt') {
          const text = await file.text();
          rows = text.split(/\r?\n/).map(line => {
            // Parse CSV line (handle quoted values)
            const result = [];
            let current = '';
            let inQuotes = false;
            for (let i = 0; i < line.length; i++) {
              const char = line[i];
              if (char === '"') {
                inQuotes = !inQuotes;
              } else if (char === ',' && !inQuotes) {
                result.push(current.trim());
                current = '';
              } else {
                current += char;
              }
            }
            result.push(current.trim());
            return result;
          }).filter(row => row.some(cell => cell.length > 0)); // Filter empty rows
        } else {
          // Excel file
          const buffer = await file.arrayBuffer();
          const workbook = XLSX.read(buffer, { type: 'array' });
          const sheetName = workbook.SheetNames[0];
          const sheet = workbook.Sheets[sheetName];
          rows = XLSX.utils.sheet_to_json(sheet, { header: 1, defval: '' });
          rows = rows.map(row => Array.isArray(row) ? row.map(cell => String(cell || '').trim()) : []);
          rows = rows.filter(row => row.some(cell => cell.length > 0)); // Filter empty rows
        }

        if (rows.length === 0) {
          return { valid: false, error: 'File is empty or contains no data rows' };
        }

        // Validate that first column has item IDs and column E (fifth column) is empty
        const invalidRows = [];
        const rowsWithDataInColumnE = [];
        
        rows.forEach((row, index) => {
          const rowNum = index + 1; // 1-based row numbering
          const firstColumn = row[0] ? String(row[0]).trim() : '';
          const fifthColumn = row[4] ? String(row[4]).trim() : ''; // Column E (index 4)
          
          // Check if first column is empty (invalid - no item ID)
          if (firstColumn.length === 0) {
            invalidRows.push(rowNum);
          }
          
          // Check if column E has data (should be empty for reference items file)
          if (fifthColumn.length > 0) {
            rowsWithDataInColumnE.push(rowNum);
          }
        });

        if (invalidRows.length > 0) {
          const rowList = invalidRows.length <= 5 
            ? invalidRows.join(', ')
            : `${invalidRows.slice(0, 5).join(', ')} and ${invalidRows.length - 5} more`;
          return { 
            valid: false, 
            error: `Invalid file: ${invalidRows.length} row(s) have empty values in the first column (Item ID). Rows with issues: ${rowList}. All rows must have an item ID in the first column.` 
          };
        }

        if (rowsWithDataInColumnE.length > 0) {
          const rowList = rowsWithDataInColumnE.length <= 5 
            ? rowsWithDataInColumnE.join(', ')
            : `${rowsWithDataInColumnE.slice(0, 5).join(', ')} and ${rowsWithDataInColumnE.length - 5} more`;
          return { 
            valid: false, 
            error: `Invalid file format: Column E (fifth column) should be empty for Reference Items File. Found data in column E on ${rowsWithDataInColumnE.length} row(s): ${rowList}. This may indicate the wrong spreadsheet was uploaded (e.g., Output CSV file instead of Reference Items File).` 
          };
        }

        // Check if first row is a header (first cell is "ItemId")
        let headerDetected = false;
        let itemCount = rows.length;
        if (rows.length > 0) {
          const firstRowFirstCell = rows[0][0] ? String(rows[0][0]).trim() : '';
          if (firstRowFirstCell.toLowerCase() === 'itemid') {
            headerDetected = true;
            itemCount = rows.length - 1; // Exclude header row from count
          }
        }

        return { valid: true, itemCount: itemCount, headerDetected: headerDetected };
      } catch (error) {
        return { valid: false, error: `Error reading file: ${error.message}` };
      }
    }

    async function validateExistingListFile(file) {
      logToConsole('[VALIDATE] validateExistingListFile called', 'info');
      if (!file) {
        logToConsole('[VALIDATE] No file provided', 'error');
        return { valid: false, error: 'No file selected' };
      }

      // Check file extension
      const extension = file.name.split('.').pop().toLowerCase();
      logToConsole(`[VALIDATE] File extension: ${extension}`, 'info');
      if (!['csv', 'xls', 'xlsx'].includes(extension)) {
        logToConsole(`[VALIDATE] Invalid file extension: ${extension}`, 'error');
        return { valid: false, error: 'File must be a CSV or Excel file (.csv, .xls, .xlsx)' };
      }

      try {
        logToConsole('[VALIDATE] Starting file parsing...', 'info');
        let rows = [];
        let headerRow = null;
        
        if (extension === 'csv') {
          const text = await file.text();
          const lines = text.split(/\r?\n/);
          lines.forEach((line, lineIndex) => {
            // Parse CSV line (handle quoted values)
            const result = [];
            let current = '';
            let inQuotes = false;
            for (let i = 0; i < line.length; i++) {
              const char = line[i];
              if (char === '"') {
                inQuotes = !inQuotes;
              } else if (char === ',' && !inQuotes) {
                result.push(current.trim());
                current = '';
              } else {
                current += char;
              }
            }
            result.push(current.trim());
            if (result.length > 0 && result.some(cell => cell.length > 0)) {
              // Check if first row is header (case-insensitive check for common header names)
              if (lineIndex === 0) {
                const firstCell = result[0] ? String(result[0]).trim().toLowerCase() : '';
                if (firstCell === 'itemid' || firstCell === 'item id' || firstCell === 'item_id') {
                  headerRow = result;
                  return; // Skip header row
                }
              }
              rows.push(result);
            }
          });
        } else {
          // Excel file
          const buffer = await file.arrayBuffer();
          const workbook = XLSX.read(buffer, { type: 'array' });
          const sheetName = workbook.SheetNames[0];
          const sheet = workbook.Sheets[sheetName];
          const allRows = XLSX.utils.sheet_to_json(sheet, { header: 1, defval: '' });
          allRows.forEach((row, rowIndex) => {
            const processedRow = Array.isArray(row) ? row.map(cell => String(cell || '').trim()) : [];
            if (processedRow.some(cell => cell.length > 0)) {
              // Check if first row is header
              if (rowIndex === 0) {
                const firstCell = processedRow[0] ? String(processedRow[0]).trim().toLowerCase() : '';
                if (firstCell === 'itemid' || firstCell === 'item id' || firstCell === 'item_id') {
                  headerRow = processedRow;
                  return; // Skip header row
                }
              }
              rows.push(processedRow);
            }
          });
        }

        logToConsole(`[VALIDATE] Parsed ${rows.length} rows, headerRow: ${headerRow ? 'yes' : 'no'}`, 'info');
        if (rows.length === 0) {
          logToConsole('[VALIDATE] No valid data rows found', 'error');
          return { valid: false, error: 'File is empty or contains no valid data rows.' };
        }

        // Map columns based on header or position
        logToConsole('[VALIDATE] Mapping columns...', 'info');
        // Expected columns: ItemID (0), DepartmentName (1), ShortDescription (2), WebURL (3), Description (4), 
        // SellingPrice (5), BasePrice (6), Color (7), ColorImageURL (8), Size (9), ImageURL1 (10), ImageURL2 (11), Style (12), ProductClass (13)
        const getColumnIndex = (headerName) => {
          if (!headerRow) return null;
          const normalized = headerName.toLowerCase().replace(/\s+/g, '').replace(/_/g, '');
          return headerRow.findIndex((h, idx) => {
            const normalizedHeader = String(h || '').trim().toLowerCase().replace(/\s+/g, '').replace(/_/g, '');
            return normalizedHeader === normalized;
          });
        };

        const itemIdIndex = getColumnIndex('ItemID') !== null && getColumnIndex('ItemID') !== -1 ? getColumnIndex('ItemID') : 0;
        const shortDescIndex = getColumnIndex('ShortDescription') !== null && getColumnIndex('ShortDescription') !== -1 ? getColumnIndex('ShortDescription') : 2;
        const imageURL1Index = getColumnIndex('ImageURL1') !== null && getColumnIndex('ImageURL1') !== -1 ? getColumnIndex('ImageURL1') : 10;
        const imageURL2Index = getColumnIndex('ImageURL2') !== null && getColumnIndex('ImageURL2') !== -1 ? getColumnIndex('ImageURL2') : 11;

        // Extract structured data
        const items = [];
        const structuredData = [];
        
        rows.forEach(row => {
          const itemId = row[itemIdIndex] ? String(row[itemIdIndex]).trim() : '';
          if (itemId.length > 0) {
            items.push(itemId);
            structuredData.push({
              itemId: itemId,
              imageURL1: row[imageURL1Index] ? String(row[imageURL1Index]).trim() : '',
              imageURL2: row[imageURL2Index] ? String(row[imageURL2Index]).trim() : '',
              shortDescription: row[shortDescIndex] ? String(row[shortDescIndex]).trim() : ''
            });
          }
        });

        logToConsole(`[VALIDATE] Extracted ${items.length} items, ${structuredData.length} structured items`, 'info');
        if (items.length === 0) {
          logToConsole('[VALIDATE] No valid ItemIDs found', 'error');
          return { valid: false, error: 'File contains no valid ItemIDs.' };
        }

        logToConsole(`[VALIDATE] ‚úì Validation successful: ${items.length} items`, 'success');
        return { 
          valid: true, 
          items: items, 
          count: items.length,
          structuredData: structuredData, // Return structured data for use in gallery
          headerDetected: headerRow !== null // Return whether header row was detected
        };
      } catch (error) {
        logToConsole(`[VALIDATE] EXCEPTION: ${error.message}`, 'error');
        logToConsole(`[VALIDATE] Stack trace: ${error.stack}`, 'error');
        return { valid: false, error: `Error reading file: ${error.message}` };
      }
    }

    async function apiCall(endpoint, data) {
      // Use human-readable names for common endpoints
      const endpointDisplayName = endpoint === 'update_wm' ? 'Update WM' : 
                                  endpoint === 'app_opened' ? 'App Opened' :
                                  endpoint === 'auth' ? 'Auth' :
                                  endpoint === 'generate_items' ? 'Generate Items' : 
                                  endpoint === 'gallery_generate' ? 'Gallery Generate' : endpoint;
      
      try {
        logToConsole(`[API] Calling ${endpointDisplayName}...`, 'info');
        logToConsole(`[API] Endpoint: /api/${endpoint}`, 'info');
        logToConsole(`[API] Payload size: ${JSON.stringify(data).length} bytes`, 'info');
        
        const url = `/api/${endpoint}`;
        const requestOptions = {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(data)
        };
        
        logToConsole(`[API] Making fetch request to ${url}...`, 'info');
        const response = await fetch(url, requestOptions);
        
        logToConsole(`[API] Response status: ${response.status} ${response.statusText}`, response.ok ? 'success' : 'error');
        logToConsole(`[API] Response headers: ${JSON.stringify(Object.fromEntries(response.headers.entries()))}`, 'info');
        
        if (!response.ok) {
          const errorText = await response.text();
          logToConsole(`[API] Error response body: ${errorText}`, 'error');
          throw new Error(`HTTP ${response.status}: ${errorText}`);
        }
        
        const result = await response.json();
        logToConsole(`[API] Response parsed successfully`, 'success');
        logToConsole(`[API] Response keys: ${Object.keys(result).join(', ')}`, 'info');
        
        if (result.success) {
          // Don't log generic success for update_wm - handleWmUpdate will log detailed summary
          if (endpoint !== 'update_wm') {
            logToConsole(`[API] ${endpointDisplayName} Succeeded`, 'success');
          }
        } else {
          logToConsole(`[API] ${endpointDisplayName} failed: ${result.error}`, 'error');
          if (result.error) {
            logToConsole(`[API] Error details: ${JSON.stringify(result.error, null, 2)}`, 'error');
          }
        }
        
        return result;
      } catch (error) {
        logToConsole(`[API] ${endpointDisplayName} exception: ${error.message}`, 'error');
        logToConsole(`[API] Error stack: ${error.stack}`, 'error');
        return { success: false, error: error.message };
      }
    }

    async function handleGenerateClick() {
      saveConfig();
      // Note: Company, Website, Item Count, and Extra Prompt fields have been removed
      // Generate Items functionality may need to be updated or disabled
      const company = '';
      const website = '';
      const count = 0;
      const extra_prompt = '';

      const genBtn = document.getElementById('genBtn');
      const genProgress = document.getElementById('genProgress');
      const genStatus = document.getElementById('genStatus');

      genBtn.disabled = true;
      genProgress.style.display = 'block';
      genStatus.textContent = 'Generating...';

      const result = await apiCall('generate_items', { company, website, count, extra_prompt });

      genBtn.disabled = false;
      genProgress.style.display = 'none';

      if (!result.success) {
        genStatus.textContent = `Error: ${result.error}`;
        return;
      }

      generatedProducts = result.products;
      // Auto-apply when generating items - no warnings, display in white
      setItemList(result.products, `${result.products.length} generated items ready for gallery.`, true);

      genStatus.textContent = `Generated ${result.count} products successfully!`;
    }

    function getSearchSource() {
      if (currentItemList.length) return currentItemList.slice();
      if (generatedProducts.length) return generatedProducts.slice();
      return referenceItems.slice();
    }

    function validateItemListFormat(items) {
      // Check if items array is empty
      if (!items || items.length === 0) {
        return { valid: false, error: 'Item list cannot be empty. Please enter at least one item.' };
      }

      // Validate format - same logic as validateExistingListFile
      // Check for common issues that suggest wrong format:
      // - Multiple items per line (comma-separated or tab-separated)
      // - CSV format indicators
      const hasMultipleItemsPerLine = items.some(item => {
        // If an item has tabs, it's likely tab-separated format
        if (item.includes('\t')) return true;
        // If an item has commas and appears to have multiple columns, it's likely CSV format
        if (item.includes(',')) {
          const parts = item.split(',').map(p => p.trim()).filter(Boolean);
          // If there are multiple non-empty parts, it might be CSV format
          if (parts.length > 1 && parts.every(p => p.length > 0)) return true;
        }
        return false;
      });

      if (hasMultipleItemsPerLine) {
        return { 
          valid: false, 
          error: 'File format appears invalid. Expected one item per line (plain text format). This file appears to be in CSV/Excel format. Please use a plain text file with one item per line.' 
        };
      }

      return { valid: true };
    }

    function validateCurrentItemListFormat() {
      // Validate format - same logic as validateExistingListFile
      // Assumes currentItemList is not empty (caller should check that first)
      return validateItemListFormat(currentItemList);
    }

    async function handleDownloadClick() {
      logToConsole('=== Download Images Button Clicked ===', 'info');
      
      // Check if todo items data is loaded
      logToConsole(`Checking todo items data... (length: ${posItemsData ? posItemsData.length : 0})`, 'info');
      if (!posItemsData || posItemsData.length === 0) {
        logToConsole('ERROR: No todo items data loaded. Please load a CSV file first.', 'error');
        alert('Please load a CSV file with ItemID, ImageURL1, ImageURL2, and ShortDescription columns before downloading images.');
        return;
      }
      logToConsole(`‚úì Todo items data found: ${posItemsData.length} items`, 'success');

      logToConsole('Calling saveConfig()...', 'info');
      try {
        saveConfig();
        logToConsole('‚úì saveConfig() completed', 'success');
      } catch (error) {
        logToConsole(`WARNING: saveConfig() failed: ${error.message}`, 'warning');
        // Continue anyway - config save is not critical
      }
      
      logToConsole('Getting sites input...', 'info');
      const sitesInput = document.getElementById('sites');
      if (!sitesInput) {
        logToConsole('ERROR: sites input element not found', 'error');
        return;
      }
      const sites = sitesInput.value.trim() || DEFAULTS.sites;
      logToConsole(`Sites: ${sites}`, 'info');
      
      // Validate Images Per Item - check raw input before applying defaults
      logToConsole('Getting images_per_item input...', 'info');
      const imagesPerItemInputEl = document.getElementById('images_per_item');
      if (!imagesPerItemInputEl) {
        logToConsole('ERROR: images_per_item input element not found', 'error');
        return;
      }
      const imagesPerItemInput = imagesPerItemInputEl.value.trim();
      logToConsole(`Images Per Item input: "${imagesPerItemInput}"`, 'info');
      if (!imagesPerItemInput || imagesPerItemInput === '') {
        logToConsole('ERROR: Images Per Item is required', 'error');
        alert('Images Per Item is required and must be greater than 0');
        return;
      }
      const images_per_item = parseInt(imagesPerItemInput);
      if (isNaN(images_per_item) || images_per_item <= 0) {
        logToConsole(`ERROR: Invalid Images Per Item value: ${imagesPerItemInput}`, 'error');
        alert('Images Per Item must be greater than 0');
        return;
      }
      logToConsole(`‚úì Images Per Item: ${images_per_item}`, 'success');
      
      logToConsole('Getting prefix input...', 'info');
      const prefixInput = document.getElementById('prefix');
      const prefix = prefixInput ? prefixInput.value.trim() : '';
      logToConsole(`Prefix: ${prefix || '(empty)'}`, 'info');
      
      logToConsole('Getting image_filters input...', 'info');
      const filterInput = document.getElementById('image_filters');
      const filter_str = filterInput ? filterInput.value.trim() : '';
      logToConsole(`Image Filters: ${filter_str || '(empty)'}`, 'info');

      // Log sample of todo items data
      if (posItemsData.length > 0) {
        logToConsole(`Sample todo item (first): ${JSON.stringify(posItemsData[0], null, 2)}`, 'info');
      } else {
        logToConsole('WARNING: posItemsData is empty', 'warning');
      }

      logToConsole('Preparing payload with todo items data...', 'info');
      // Prepare payload with todo items data
      lastGalleryPayload = {
        posItems: posItemsData, // Send structured POS items data
        sites,
        images_per_item,
        prefix,
        image_filters: filter_str
      };

      logToConsole(`Prepared payload summary: ${JSON.stringify({
        posItemsCount: lastGalleryPayload.posItems.length,
        sites: lastGalleryPayload.sites,
        images_per_item: lastGalleryPayload.images_per_item,
        prefix: lastGalleryPayload.prefix,
        image_filters: lastGalleryPayload.image_filters
      }, null, 2)}`, 'info');
      
      logToConsole('Getting DOM elements (dlBtn, dlProgress, dlStatus)...', 'info');

      const dlBtn = document.getElementById('dlBtn');
      const dlProgress = document.getElementById('dlProgress');
      const dlStatus = document.getElementById('dlStatus');

      if (!dlBtn || !dlProgress || !dlStatus) {
        logToConsole('ERROR: Required DOM elements not found (dlBtn, dlProgress, or dlStatus)', 'error');
        return;
      }

      dlBtn.disabled = true;
      dlProgress.style.display = 'block';
      dlStatus.textContent = 'Preparing gallery...';
      logToConsole('Calling API: gallery_generate...', 'info');

      try {
        const result = await apiCall('gallery_generate', lastGalleryPayload);
        
        logToConsole(`API call completed. Success: ${result.success}`, result.success ? 'success' : 'error');
        
        if (result.error) {
          logToConsole(`API Error: ${result.error}`, 'error');
        }
        
        if (result.items) {
          logToConsole(`API returned ${result.items.length} items`, 'success');
          if (result.items.length > 0) {
            logToConsole(`Sample item structure: ${JSON.stringify({
              itemId: result.items[0].itemId,
              url1VariantsCount: result.items[0].url1Variants?.length || 0,
              url2VariantsCount: result.items[0].url2Variants?.length || 0
            }, null, 2)}`, 'info');
          }
        }
        
        if (result.missingItems && result.missingItems.length > 0) {
          logToConsole(`Missing items: ${JSON.stringify(result.missingItems, null, 2)}`, 'warning');
        }

        dlBtn.disabled = false;
        dlProgress.style.display = 'none';

        if (!result.success) {
          logToConsole(`ERROR: Gallery generation failed - ${result.error || 'Unknown error'}`, 'error');
          dlStatus.textContent = `Error: ${result.error || 'Unable to generate gallery'}`;
          return;
        }

        galleryItems = result.items || [];
        logToConsole(`Gallery items set: ${galleryItems.length} items`, 'success');
        
        // Preserve ShortDescription from posItemsData if not in API response
        if (posItemsData && posItemsData.length > 0) {
          const posItemsMap = new Map();
          posItemsData.forEach(posItem => {
            posItemsMap.set(posItem.itemId, posItem);
          });
          
          galleryItems.forEach(item => {
            const posItem = posItemsMap.get(item.itemId);
            if (posItem && posItem.shortDescription) {
              item.ShortDescription = posItem.shortDescription;
            }
          });
        }
        
        // Assign permanent positionLabels to all variants (if not already assigned)
        // These labels are the permanent identity of each card and NEVER change
        galleryItems.forEach(item => {
          // Assign permanent labels to URL1 variants
          if (item.url1Variants && item.url1Variants.length > 0) {
            item.url1Variants.forEach((variant, idx) => {
              if (!variant.positionLabel) {
                variant.positionLabel = 'URL1'; // Permanent label - assigned once, never changes
              }
            });
          }
          
          // Assign permanent labels to URL2 variants
          if (item.url2Variants && item.url2Variants.length > 0) {
            item.url2Variants.forEach((variant, idx) => {
              if (!variant.positionLabel) {
                variant.positionLabel = 'URL2'; // Permanent label - assigned once, never changes
              }
            });
          }
          
          // Assign permanent labels to Google variants
          if (item.googleVariants && item.googleVariants.length > 0) {
            item.googleVariants.forEach((variant, idx) => {
              if (!variant.positionLabel) {
                variant.positionLabel = `Variant ${idx + 1}`; // Permanent label - assigned once, never changes
              }
            });
          }
        });
        
        // Store original URL1/URL2 for each item (for reset functionality and red badges)
        galleryItems.forEach(item => {
          if (!item.originalUrl1) {
            item.originalUrl1 = item.url1Variants && item.url1Variants.length > 0 
              ? { ...item.url1Variants[0] } 
              : null;
          }
          if (!item.originalUrl2) {
            item.originalUrl2 = item.url2Variants && item.url2Variants.length > 0 
              ? { ...item.url2Variants[0] } 
              : null;
          }
        });
        
        gallerySelections = {};
        gallerySkippedItems.clear(); // Clear skipped items for new gallery
        galleryNewImages.clear(); // Clear new images tracking for new gallery
        galleryMissingItems = result.missingItems || [];
        
        logToConsole(`Opening gallery modal with ${galleryItems.length} items...`, 'info');
        dlStatus.textContent = 'Gallery ready.';
        openGalleryModal();
        logToConsole('‚úì Gallery modal opened successfully', 'success');
      } catch (error) {
        logToConsole(`EXCEPTION in handleDownloadClick: ${error.message}`, 'error');
        logToConsole(`Stack trace: ${error.stack}`, 'error');
        const dlBtn = document.getElementById('dlBtn');
        const dlProgress = document.getElementById('dlProgress');
        const dlStatus = document.getElementById('dlStatus');
        if (dlBtn) dlBtn.disabled = false;
        if (dlProgress) dlProgress.style.display = 'none';
        if (dlStatus) dlStatus.textContent = `Error: ${error.message}`;
      }
    }

    function openGalleryModal() {
      logToConsole('[GALLERY] Opening gallery modal...', 'info');
      const galleryModal = document.getElementById('galleryModal');
      if (!galleryModal) {
        logToConsole('[GALLERY] ERROR: galleryModal element not found', 'error');
        return;
      }
      galleryModal.classList.add('show');
      logToConsole('[GALLERY] Modal class "show" added', 'success');
      logToConsole('[GALLERY] Rendering gallery...', 'info');
      renderGallery();
      logToConsole('[GALLERY] Gallery rendered', 'success');
      setGalleryStatus('');
      logToConsole('[GALLERY] Gallery modal opened successfully', 'success');
    }

    function closeGalleryModal() {
      document.getElementById('galleryModal').classList.remove('show');
      setGalleryStatus('');
    }

    function renderGallery(disableAnimations = false) {
      // Clear DOM cache before full render to ensure fresh references
      domCache.clearCache();
      const grid = domCache.getGalleryGrid();
      
      // Save scroll position to prevent auto-scroll
      const scrollTop = grid ? grid.scrollTop : 0;
      const scrollLeft = grid ? grid.scrollLeft : 0;
      
      // If disabling animations, temporarily disable transitions on all existing tracks before clearing
      if (disableAnimations) {
        const existingTracks = grid.querySelectorAll('.slider-track');
        existingTracks.forEach(track => {
          track.style.transition = 'none';
        });
      }
      
      grid.innerHTML = '';
      
      // Restore scroll position after clearing
      if (grid) {
        grid.scrollTop = scrollTop;
        grid.scrollLeft = scrollLeft;
      }

      galleryItems.forEach((item, itemIndex) => {
        const group = document.createElement('div');
        group.className = 'gallery-group';

        const header = document.createElement('div');
        header.className = 'gallery-group-header';
        // For todo items, use itemId: ShortDescription as display title
        const displayTitle = item.ShortDescription 
          ? `${item.itemId}: ${item.ShortDescription}`
          : item.itemId;
        // Use unique key for skip state to prevent collisions when items share same itemId
        const uniqueKey = getUniqueKey(itemIndex, item.itemId);
        const isSkipped = gallerySkippedItems.has(uniqueKey);
        
        // Create header with item name on left
        const titleDiv = document.createElement('div');
        const h5 = document.createElement('h5');
        h5.textContent = displayTitle;
        // Add image count display next to item name (Google images only, excluding positions 1 and 2)
        const googleCount = (item.googleVariants || []).length;
        const countSpan = document.createElement('span');
        countSpan.style.color = '#9aa4d3'; // Different color (matching source text color)
        countSpan.style.marginLeft = '0.5rem';
        countSpan.style.fontSize = '0.9em';
        countSpan.textContent = `(${googleCount})`;
        h5.appendChild(countSpan);
        titleDiv.appendChild(h5);
        
        // Create page indicator (will be updated by slider) - centered in header
        const pageIndicator = document.createElement('div');
        pageIndicator.className = 'gallery-page-indicator';
        pageIndicator.style.cssText = 'font-size: 0.75rem; color: #9aa4d3; position: absolute; left: 50%; transform: translateX(-50%);';
        pageIndicator.textContent = 'Page 1 of 1'; // Will be updated by updateSlider
        
        // Create controls (checkbox and refresh button) on right
        const controlsDiv = document.createElement('div');
        controlsDiv.className = 'gallery-controls';
        
        const skipCheckbox = document.createElement('input');
        skipCheckbox.type = 'checkbox';
        skipCheckbox.className = 'skip-checkbox';
        skipCheckbox.checked = isSkipped;
        skipCheckbox.title = 'Skip this item';
        skipCheckbox.addEventListener('change', () => {
          if (skipCheckbox.checked) {
            gallerySkippedItems.add(uniqueKey);
            // Clear selection if item is skipped (use unique key)
            delete gallerySelections[uniqueKey];
          } else {
            gallerySkippedItems.delete(uniqueKey);
          }
          // Update only the affected row instead of re-rendering entire gallery
          updateGalleryRow(uniqueKey);
          updateGallerySummary();
          updateGalleryToolbar();
        });
        
        const refreshBtn = document.createElement('button');
        refreshBtn.className = 'refresh-btn';
        refreshBtn.type = 'button';
        refreshBtn.innerHTML = '<span>üîÑ</span> Add New Images';
        refreshBtn.title = 'Add new images for this item';
        refreshBtn.addEventListener('click', async (e) => {
          e.stopPropagation();
          await handleRefreshImages(item.itemId, refreshBtn);
        });
        
        // Add Reset button for todo items
        let resetBtn = null;
        if (item.url1Variants !== undefined || item.url2Variants !== undefined) {
          resetBtn = document.createElement('button');
          resetBtn.className = 'reset-btn';
          resetBtn.type = 'button';
          resetBtn.innerHTML = '<span>‚Ü∫</span>';
          resetBtn.title = 'Reset URL1 and URL2 to original images';
          resetBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            resetItemUrls(item.itemId);
          });
        }
        
        controlsDiv.appendChild(skipCheckbox);
        controlsDiv.appendChild(refreshBtn);
        if (resetBtn) controlsDiv.appendChild(resetBtn);
        
        // Make header position relative so page indicator can be absolutely positioned
        header.style.position = 'relative';
        header.appendChild(titleDiv);
        header.appendChild(pageIndicator);
        header.appendChild(controlsDiv);
        
        if (isSkipped) {
          group.classList.add('skipped');
        }
        
        group.appendChild(header);

        // Check if this is a POS item with URL1/URL2 structure
        const hasURLRows = item.url1Variants !== undefined || item.url2Variants !== undefined;
        logToConsole(`[GALLERY] Item ${item.itemId}: hasURLRows=${hasURLRows}, url1Variants=${item.url1Variants?.length || 0}, url2Variants=${item.url2Variants?.length || 0}, googleVariants=${item.googleVariants?.length || 0}`, 'info');
        
        if (hasURLRows) {
          // Build combined variants array: URL1 (position 0), URL2 (position 1), then Google images
          const combinedVariants = [];
          
          // Position 1: URL1
          if (item.url1Variants && item.url1Variants.length > 0) {
            const url1Variant = item.url1Variants[0];
            // Check if this is the original URL1 image
            const isOriginalUrl1 = item.originalUrl1 && url1Variant.originalUrl === item.originalUrl1.originalUrl;
            // If originalUrl1 is not set yet, this is the first/original image, so set isOriginal to true
            const isOriginal = isOriginalUrl1 || !item.originalUrl1;
            
            // Preserve existing positionLabel if it exists (from previous swaps), otherwise assign 'URL1'
            // Once assigned, this label should NEVER change - it's the permanent identity of the card
            const positionLabel = url1Variant.positionLabel || 'URL1';
            
            logToConsole(`[RENDER] URL1 variant: isOriginal=${isOriginal}, isOriginalUrl1=${isOriginalUrl1}, originalUrl=${url1Variant.originalUrl}, positionLabel=${positionLabel}, variant.positionLabel=${url1Variant.positionLabel}`, 'info');
            
            combinedVariants.push({
              ...url1Variant,
              positionLabel: positionLabel, // Preserve existing label or assign 'URL1' (permanent)
              isUrlImage: true,
              isOriginal: isOriginal
            });
          } else {
            // Placeholder for URL1
            combinedVariants.push({
              fileName: 'URL1_placeholder',
              previewUrl: '',
              originalUrl: '_PLACEHOLDER_',
              source: 'URL1',
              shortDescription: '',
              description: '',
              isPlaceholder: true,
              positionLabel: 'URL1',
              isUrlImage: true
            });
          }
          
          // Position 2: URL2
          if (item.url2Variants && item.url2Variants.length > 0) {
            const url2Variant = item.url2Variants[0];
            // Check if this is the original URL2 image
            const isOriginalUrl2 = item.originalUrl2 && url2Variant.originalUrl === item.originalUrl2.originalUrl;
            // If originalUrl2 is not set yet, this is the first/original image, so set isOriginal to true
            const isOriginal = isOriginalUrl2 || !item.originalUrl2;
            
            // Preserve existing positionLabel if it exists (from previous swaps), otherwise assign 'URL2'
            // Once assigned, this label should NEVER change
            const positionLabel = url2Variant.positionLabel || 'URL2';
            
            logToConsole(`[RENDER] URL2 variant: isOriginal=${isOriginal}, isOriginalUrl2=${isOriginalUrl2}, originalUrl=${url2Variant.originalUrl}, positionLabel=${positionLabel}`, 'info');
            
            combinedVariants.push({
              ...url2Variant,
              positionLabel: positionLabel, // Preserve existing label or assign 'URL2' (permanent)
              isUrlImage: true,
              isOriginal: isOriginal
            });
          } else {
            // Placeholder for URL2
            combinedVariants.push({
              fileName: 'URL2_placeholder',
              previewUrl: '',
              originalUrl: '_PLACEHOLDER_',
              source: 'URL2',
              shortDescription: '',
              description: '',
              isPlaceholder: true,
              positionLabel: 'URL2',
              isUrlImage: true
            });
          }
          
          // Position 3+: Google images - sort by Variant number
          if (item.googleVariants && item.googleVariants.length > 0) {
            // Sort googleVariants by Variant number (extract number from positionLabel)
            // Items with URL1/URL2 labels maintain their current array position
            const sortedGoogleVariants = [...item.googleVariants].map((variant, originalIndex) => ({
              variant,
              originalIndex
            })).sort((a, b) => {
              const getVariantNumber = (variant) => {
                const label = variant.positionLabel || '';
                // Extract number from "Variant X" 
                const match = label.match(/^Variant (\d+)$/);
                if (match) {
                  return parseInt(match[1], 10);
                }
                // For URL1/URL2 labels, use original array index to maintain position
                // This preserves where they were swapped to
                if (label === 'URL1' || label === 'URL2') {
                  return variant.originalIndex + 10000; // Use original index + offset to maintain position
                }
                return 0;
              };
              const numA = getVariantNumber(a.variant);
              const numB = getVariantNumber(b.variant);
              // If both are Variant numbers, sort by number
              // If one is URL1/URL2, maintain relative order based on original index
              if (numA >= 10000 && numB >= 10000) {
                return numA - numB; // Both are URL1/URL2, sort by original index
              }
              if (numA >= 10000) {
                return 1; // a is URL1/URL2, b is Variant - URL1/URL2 goes after Variants
              }
              if (numB >= 10000) {
                return -1; // b is URL1/URL2, a is Variant - Variant goes before URL1/URL2
              }
              return numA - numB; // Both are Variants, sort by number
            }).map(item => item.variant);
            
            sortedGoogleVariants.forEach((variant) => {
              // Check if this Google image was originally a URL1/URL2 image (has isOriginal flag)
              const isOriginal = variant.isOriginal || false;
              // Preserve existing positionLabel (URL1/URL2) if it exists, otherwise use Variant X
              // Once assigned, this label should NEVER change
              const positionLabel = variant.positionLabel || 'Variant 1';
              
              logToConsole(`[RENDER] Google variant: isOriginal=${isOriginal}, positionLabel=${positionLabel}, originalUrl=${variant.originalUrl}`, 'info');
              
              combinedVariants.push({
                ...variant,
                positionLabel: positionLabel, // Preserve existing label or assign Variant X (permanent)
                isUrlImage: false,
                isOriginal: isOriginal // Preserve isOriginal flag for red badge
              });
            });
          }
          
          logToConsole(`[GALLERY] Rendering single row with ${combinedVariants.length} variants (URL1, URL2, ${item.googleVariants?.length || 0} Google images)`, 'info');
          
          // Render single row with all variants
          const singleRow = renderSingleRow(itemIndex, item, combinedVariants, uniqueKey, disableAnimations);
          group.appendChild(singleRow);
          
          grid.appendChild(group);
          logToConsole(`[GALLERY] Item ${item.itemId} added to grid`, 'success');
          return;
        }

        // Legacy support: if item has variants (old structure), render as before
        if (!item.variants || item.variants.length === 0) {
          const empty = document.createElement('div');
          empty.className = 'gallery-empty';
          empty.textContent = 'No images returned for this item.';
          group.appendChild(empty);
          grid.appendChild(group);
          return;
        }

        const sliderWrapper = document.createElement('div');
        sliderWrapper.className = 'variant-slider';
        const prevBtn = document.createElement('button');
        prevBtn.className = 'slider-nav-btn slider-nav-prev';
        prevBtn.innerHTML = '&#8249;';
        const nextBtn = document.createElement('button');
        nextBtn.className = 'slider-nav-btn slider-nav-next';
        nextBtn.innerHTML = '&#8250;';
        const viewport = document.createElement('div');
        viewport.className = 'slider-viewport';
        const track = document.createElement('div');
        track.className = 'slider-track';

        item.variants.forEach((variant, idx) => {
          const card = document.createElement('div');
          card.className = 'gallery-card';
          // Use array index to create unique key - fixes collision when multiple items have same itemId
          const uniqueKey = `${itemIndex}_${item.itemId}`;
          const currentItemId = item.itemId;
          const currentFileName = variant.fileName;
          const isSelected = gallerySelections[uniqueKey] === currentFileName;
          if (isSelected) card.classList.add('selected');
          
          // Check if this is a new image
          const isNewImage = galleryNewImages.has(currentItemId) && 
                             galleryNewImages.get(currentItemId).has(variant.originalUrl);
          
          const newBadgeHtml = isNewImage ? '<div class="new-images-badge">NEW</div>' : '';
          
          card.innerHTML = `
            <div class="gallery-card-image" style="position: relative;">
              <img src="${variant.previewUrl || variant.originalUrl}" alt="${variant.fileName}">
              ${newBadgeHtml}
            </div>
            <div class="gallery-card-body">
              <div class="gallery-card-title">Variant ${idx + 1}</div>
              <div class="gallery-card-source">${variant.source || 'Unknown'}</div>
            </div>
            <button class="gallery-preview-btn" type="button">Preview</button>
          `;
          // Use unique key (itemIndex + itemId) to prevent collisions when items share same itemId
          card.addEventListener('click', () => toggleGallerySelection(uniqueKey, currentFileName, currentItemId));
          const previewBtn = card.querySelector('.gallery-preview-btn');
          previewBtn.addEventListener('click', (ev) => {
            ev.stopPropagation();
            openVariantCarousel(item, idx);
          });
          track.appendChild(card);
        });

        viewport.appendChild(track);
        sliderWrapper.appendChild(prevBtn);
        sliderWrapper.appendChild(viewport);
        sliderWrapper.appendChild(nextBtn);
        // Restore saved slider position if it exists, otherwise start at 0
        // Note: This is only used on initial render. After that, sliderState.index is maintained in the closure
        const savedIndex = gallerySliderPositions[uniqueKey] || 0;
        const sliderState = { index: savedIndex, visible: 4, cardWidth: 210 }; // Updated to match new card width

        const updateSlider = () => {
          const card = track.querySelector('.gallery-card');
          if (card) {
            // getBoundingClientRect().width includes padding and border, but NOT margin
            // We need to add margin (3px on each side = 6px total) to get full card space
            const cardRect = card.getBoundingClientRect();
            const cardStyle = window.getComputedStyle(card);
            const marginLeft = parseFloat(cardStyle.marginLeft) || 0;
            const marginRight = parseFloat(cardStyle.marginRight) || 0;
            sliderState.cardWidth = cardRect.width + marginLeft + marginRight; // Full card width including margins
          }
          const gap = 8; // Match slider-track gap (0.5rem = 8px) - must match CSS gap value
          // viewport width is the slider-viewport (space between arrows), which is correct
          const viewportWidth = viewport.getBoundingClientRect().width;
          
          // Calculate how many cards fit fully in viewport (for scrolling by pages)
          // Total space per card = card width (including margins) + gap between cards
          const spacePerCard = sliderState.cardWidth + gap;
          // Remove artificial cap - let it calculate based on actual viewport width
          sliderState.visible = Math.max(1, Math.floor(viewportWidth / spacePerCard));
          
          // Max index: largest page boundary (multiple of visible) that doesn't exceed total variants
          // Example: 18 variants, 5 visible -> last page boundary = floor(17/5)*5 = 15 (shows variants 16-18)
          // Example: 12 variants, 5 visible -> last page boundary = floor(11/5)*5 = 10 (shows variants 11-12)
          // This ensures the last page starts at a proper page boundary (variant 1, 6, 11, 16, etc.)
          // NOTE: Pagination functions (arrows, adding new images) work correctly with this logic
          const lastPageBoundary = Math.floor((item.variants.length - 1) / sliderState.visible) * sliderState.visible;
          const maxIndex = Math.max(0, lastPageBoundary);
          
          // Helper function to align index to page boundaries (multiples of visible)
          // This ensures we always show full pages (variant 1, 6, 11, etc. in leftmost position)
          const alignToPageBoundary = (index, maxIdx, visible) => {
            // Align to the nearest page boundary (multiple of visible)
            // Round down to ensure we don't overshoot
            let aligned = Math.floor(index / visible) * visible;
            // Clamp to maxIndex (which is already a page boundary)
            return Math.min(aligned, maxIdx);
          };
          
          // Clamp index to valid range first
          sliderState.index = Math.min(sliderState.index, maxIndex);
          
          // Align to page boundary to prevent drift (ensures variant 1, 6, 11, etc. in leftmost position)
          sliderState.index = alignToPageBoundary(sliderState.index, maxIndex, sliderState.visible);
          
          // Save slider position for this item so it persists across re-renders
          // This ensures the position is preserved when renderGallery() is called
          gallerySliderPositions[uniqueKey] = sliderState.index;
          
          // Calculate offset - always aligns to card boundaries (leftmost card fully visible)
          // Use spacePerCard to ensure proper alignment including margins
          const offset = -spacePerCard * sliderState.index;
          
          // Check if this is the initial render (track has no transform yet)
          const isInitialRender = !track.style.transform || track.style.transform === 'none' || track.style.transform === '';
          
          if (isInitialRender && sliderState.index > 0) {
            // On initial render with saved position, disable transition to prevent animation
            track.style.transition = 'none';
            track.style.transform = `translateX(${offset}px)`;
            // Force reflow to ensure transform is applied
            track.offsetHeight;
            // Re-enable transition for future user interactions
            track.style.transition = '';
          } else {
            // Normal update - use transition for smooth scrolling
            track.style.transform = `translateX(${offset}px)`;
          }
          
          // Smart arrow visibility logic - use actual rendered dimensions for accuracy
          const trackWidth = track.scrollWidth; // Total width of all cards including gaps
          const viewportClientWidth = viewport.clientWidth; // Visible width
          const needsScrolling = trackWidth > viewportClientWidth;
          const isAtStart = sliderState.index === 0;
          
          // At end: when scrolling further right would show empty space or we're at the last card
          // Check if the right edge of the viewport has reached or passed the right edge of the track
          const currentOffset = -(sliderState.cardWidth + gap) * sliderState.index;
          const maxOffset = viewportClientWidth - trackWidth; // Negative value when track is wider than viewport
          const isAtEnd = !needsScrolling || currentOffset <= maxOffset || sliderState.index >= maxIndex;
          
          // Left arrow: hidden at start, visible when scrolled right
          if (isAtStart || !needsScrolling) {
            prevBtn.style.display = 'none';
          } else {
            prevBtn.style.display = 'flex';
          }
          
          // Right arrow: hidden if all images fit, or if at end
          if (!needsScrolling || isAtEnd) {
            nextBtn.style.display = 'none';
          } else {
            nextBtn.style.display = 'flex';
          }
          
          // Update disabled state for accessibility
          // Only disable when truly at boundaries (prev at start, next at end)
          prevBtn.disabled = isAtStart && needsScrolling;
          nextBtn.disabled = isAtEnd && needsScrolling;
          
          // Update page indicator (page X of Y)
          // Calculate current page based on which variant is leftmost visible
          // sliderState.index is the 0-based index of the leftmost visible variant
          // Calculate total pages first
          const totalPages = needsScrolling ? Math.ceil(item.variants.length / sliderState.visible) : 1;
          
          // Calculate current page: index 0 = page 1, index 5 = page 2, etc.
          // But if we're at or past maxIndex, we're on the last page
          // Note: maxIndex is already calculated above, so we reuse it
          let currentPage;
          if (sliderState.index >= maxIndex) {
            // We're at the last page (showing the last set of variants)
            currentPage = totalPages;
          } else {
            // Normal calculation: floor(index / visible) + 1
            currentPage = Math.floor(sliderState.index / sliderState.visible) + 1;
          }
          
          // Clamp currentPage to valid range (safety check)
          const clampedCurrentPage = Math.min(Math.max(1, currentPage), totalPages);
          
          const pageIndicator = group.querySelector('.gallery-page-indicator');
          if (pageIndicator) {
            pageIndicator.textContent = `Page ${clampedCurrentPage} of ${totalPages}`;
          }
        };

        prevBtn.addEventListener('click', () => {
          // Go back by number of fully visible cards, ensuring leftmost card is always fully visible
          // Recalculate visible count to ensure it's current (in case item.variants.length changed)
          const gap = 8; // Match slider-track gap (0.5rem = 8px)
          const spacePerCard = sliderState.cardWidth + gap;
          const viewportWidth = viewport.getBoundingClientRect().width;
          const visible = Math.max(1, Math.floor(viewportWidth / spacePerCard));
          sliderState.visible = visible; // Update visible count
          
          // Calculate maxIndex (last page boundary) for alignment
          const lastPageBoundary = Math.floor((item.variants.length - 1) / visible) * visible;
          const maxIdx = Math.max(0, lastPageBoundary);
          
          // Go back by one page (visible cards), then align to page boundary
          let newIndex = Math.max(0, sliderState.index - visible);
          
          // Align to page boundary to ensure we're at variant 1, 6, 11, etc.
          // Round down to the nearest multiple of visible, then clamp to maxIdx
          newIndex = Math.floor(newIndex / visible) * visible;
          newIndex = Math.min(newIndex, maxIdx);
          
          // Ensure we don't go below 0
          sliderState.index = Math.max(0, newIndex);
          updateSlider();
        });
        nextBtn.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          // Advance by number of fully visible cards, ensuring leftmost card is always fully visible
          // Use the same calculation as updateSlider() for consistency
          const gap = 8; // Match slider-track gap (0.5rem = 8px)
          const spacePerCard = sliderState.cardWidth + gap;
          const viewportWidth = viewport.getBoundingClientRect().width;
          const visible = Math.max(1, Math.floor(viewportWidth / spacePerCard));
          sliderState.visible = visible; // Update visible count
          
          // Calculate maxIndex (last page boundary) for alignment - MUST match updateSlider() logic
          const lastPageBoundary = Math.floor((item.variants.length - 1) / visible) * visible;
          const maxIdx = Math.max(0, lastPageBoundary);
          
          // Advance by one page (visible cards), then align to page boundary
          let newIndex = sliderState.index + visible;
          
          // Align to page boundary to ensure we're at variant 1, 6, 11, etc.
          // Round down to the nearest multiple of visible, then clamp to maxIdx
          newIndex = Math.floor(newIndex / visible) * visible;
          newIndex = Math.min(newIndex, maxIdx);
          
          // Only update if we actually moved (prevents getting stuck)
          if (newIndex > sliderState.index) {
            sliderState.index = newIndex;
            updateSlider();
          }
          updateSlider();
        });
        window.addEventListener('resize', updateSlider);
        // Initial calculation - use requestAnimationFrame to ensure DOM is fully rendered
        requestAnimationFrame(() => {
          updateSlider();
          // Double-check after a brief delay to catch any late-rendering issues
          setTimeout(updateSlider, 100);
        });

        group.appendChild(sliderWrapper);
        grid.appendChild(group);
      });

      logToConsole(`[GALLERY] All items rendered. Updating warnings, toolbar, and summary...`, 'info');
      updateGalleryWarnings();
      updateGalleryToolbar();
      updateGallerySummary();
      logToConsole(`[GALLERY] renderGallery() completed successfully`, 'success');
    }

    function updateGalleryToolbar() {
      const saveBtn = document.getElementById('gallerySaveBtn');
      
      // Check if every row is accounted for: URL1 AND URL2 populated OR row is skipped
      const incompleteItems = galleryItems.filter((item, itemIndex) => {
        const uniqueKey = getUniqueKey(itemIndex, item.itemId);
        const isSkipped = gallerySkippedItems.has(uniqueKey);
        
        // If skipped, it's complete (accounted for)
        if (isSkipped) {
          return false; // Not incomplete - skipped items are accounted for
        }
        
        // Check if position 1 (URL1) has an image (not a placeholder)
        const url1Variant = item.url1Variants && item.url1Variants.length > 0 ? item.url1Variants[0] : null;
        const hasUrl1 = url1Variant && !url1Variant.isPlaceholder && url1Variant.originalUrl !== '_PLACEHOLDER_';
        
        // Check if position 2 (URL2) has an image (not a placeholder)
        const url2Variant = item.url2Variants && item.url2Variants.length > 0 ? item.url2Variants[0] : null;
        const hasUrl2 = url2Variant && !url2Variant.isPlaceholder && url2Variant.originalUrl !== '_PLACEHOLDER_';
        
        // Item is incomplete if it doesn't have BOTH URL1 AND URL2 populated
        return !hasUrl1 || !hasUrl2;
      });
      
      const isDisabled = incompleteItems.length > 0 || galleryLoading;
      
      // Update download button
      if (saveBtn) {
        saveBtn.disabled = isDisabled;
        logToConsole(`[TOOLBAR] Incomplete items: ${incompleteItems.length}, skipped items: ${gallerySkippedItems.size}, Download button disabled: ${isDisabled}`, 'info');
      }
      
      const selectFirstBtn = document.getElementById('gallerySelectFirstBtn');
      const refreshBtn = document.getElementById('galleryRefreshBtn');
      if (selectFirstBtn) {
        selectFirstBtn.disabled = galleryItems.length === 0 || galleryLoading;
      }
      if (refreshBtn) {
        refreshBtn.disabled = galleryLoading;
      }
    }

    function updateGallerySummary() {
      const summaryEl = document.getElementById('gallerySelectionSummary');
      if (!summaryEl) return;
      
      // Count total items (all rows)
      const total = galleryItems.length;
      
      // Count items that are ready: URL1 AND URL2 populated OR row is skipped
      const ready = galleryItems.filter((item, itemIndex) => {
        const uniqueKey = getUniqueKey(itemIndex, item.itemId);
        const isSkipped = gallerySkippedItems.has(uniqueKey);
        
        // If skipped, it's ready (accounted for)
        if (isSkipped) {
          return true;
        }
        
        // Check if position 1 (URL1) has an image (not a placeholder)
        const url1Variant = item.url1Variants && item.url1Variants.length > 0 ? item.url1Variants[0] : null;
        const hasUrl1 = url1Variant && !url1Variant.isPlaceholder && url1Variant.originalUrl !== '_PLACEHOLDER_';
        
        // Check if position 2 (URL2) has an image (not a placeholder)
        const url2Variant = item.url2Variants && item.url2Variants.length > 0 ? item.url2Variants[0] : null;
        const hasUrl2 = url2Variant && !url2Variant.isPlaceholder && url2Variant.originalUrl !== '_PLACEHOLDER_';
        
        // Item is ready if it has BOTH URL1 AND URL2 populated
        return hasUrl1 && hasUrl2;
      }).length;
      
      // Count skipped items
      const skippedCount = gallerySkippedItems.size;
      
      // Build summary text with skipped count only if there are skipped items
      let summaryText = `${ready} of ${total} items ready`;
      if (skippedCount > 0) {
        summaryText += ` (${skippedCount} skipped)`;
      }
      
      summaryEl.textContent = summaryText;
    }

    function getItemDisplayLabel(itemId) {
      const item = galleryItems.find(entry => entry.itemId === itemId);
      if (item) {
        return item.productName || item.itemId;
      }
      return itemId;
    }

    function updateGalleryWarnings() {
      const warningsContainer = document.getElementById('galleryWarnings');
      const instructionEl = document.getElementById('galleryInstructionMessage');
      
      // Helper to check if item has any variants (support both old and new structure)
      const hasVariants = (item) => {
        if (item.variants && Array.isArray(item.variants)) {
          return item.variants.length > 0;
        }
        // New structure: check url1Variants, url2Variants, and googleVariants
        const url1Count = (item.url1Variants && Array.isArray(item.url1Variants)) ? item.url1Variants.length : 0;
        const url2Count = (item.url2Variants && Array.isArray(item.url2Variants)) ? item.url2Variants.length : 0;
        const googleCount = (item.googleVariants && Array.isArray(item.googleVariants)) ? item.googleVariants.length : 0;
        return url1Count > 0 || url2Count > 0 || googleCount > 0;
      };
      
      const groupsWithoutImages = galleryItems
        .filter(item => !hasVariants(item))
        .map(item => getItemDisplayLabel(item.itemId));
      const groupsMissingSelections = galleryItems
        .filter((item, itemIndex) => {
          const uniqueKey = getUniqueKey(itemIndex, item.itemId);
          return hasVariants(item) && 
                 !gallerySkippedItems.has(uniqueKey) && 
                 !gallerySelections[uniqueKey];
        })
        .map(item => getItemDisplayLabel(item.itemId));

      // Instruction message removed per user request
      if (instructionEl) {
        instructionEl.textContent = '';
      }

      const summarizeList = (arr, limit = 12) => {
        if (arr.length <= limit) return arr.join(', ');
        const remaining = arr.length - limit;
        return `${arr.slice(0, limit).join(', ')}, ‚Ä¶ (+${remaining})`;
      };

      let warningsHtml = '';
      if (groupsWithoutImages.length > 0) {
        warningsHtml += `<div class="gallery-warning hidden-warning">Warning: No images returned for ${summarizeList(groupsWithoutImages)}</div>`;
      }
      if (groupsMissingSelections.length > 0) {
        warningsHtml += `<div class="gallery-warning hidden-warning">Missing selections for: ${summarizeList(groupsMissingSelections)}</div>`;
      }
      if (galleryMissingItems.length > 0) {
        const detailList = galleryMissingItems.map(m => {
          const label = getItemDisplayLabel(m.itemId);
          return `${label}${m.reason ? ` (${m.reason})` : ''}`;
        });
        warningsHtml += `<div class="gallery-warning hidden-warning">Gallery API could not find images for: ${summarizeList(detailList)}</div>`;
      }
      warningsContainer.innerHTML = warningsHtml;
      // Tooltip removed per user request
    }

    // Helper function to create unique key from item index and itemId
    function getUniqueKey(itemIndex, itemId) {
      return `${itemIndex}_${itemId}`;
    }

    // Helper function to render a single row with URL1, URL2, and Google images
    function renderSingleRow(itemIndex, item, variants, uniqueKey, disableAnimations = false) {
      const rowContainer = document.createElement('div');
      rowContainer.className = 'variant-slider';
      
      const prevBtn = document.createElement('button');
      prevBtn.className = 'slider-nav-btn slider-nav-prev';
      prevBtn.innerHTML = '&#8249;';
      const nextBtn = document.createElement('button');
      nextBtn.className = 'slider-nav-btn slider-nav-next';
      nextBtn.innerHTML = '&#8250;';
      const viewport = document.createElement('div');
      viewport.className = 'slider-viewport';
      const track = document.createElement('div');
      track.className = 'slider-track';
      
      const rowKey = uniqueKey;
      
      // Split variants: positions 0-1 (URL1/URL2) are fixed, positions 2+ are scrollable
      const fixedVariants = variants.slice(0, 2); // URL1 and URL2
      const scrollableVariants = variants.slice(2); // Google images
      
      // Create fixed container for URL1/URL2 with green background
      const fixedContainer = document.createElement('div');
      fixedContainer.className = 'url-positions-fixed';
      fixedContainer.style.cssText = 'display: flex; gap: 8px; flex-shrink: 0;';
      
      // Render fixed positions (URL1/URL2)
      fixedVariants.forEach((variant, idx) => {
        const card = document.createElement('div');
        card.className = 'gallery-card';
        const currentFileName = variant.fileName;
        const isSelected = gallerySelections[uniqueKey] === currentFileName;
        if (isSelected) card.classList.add('selected');
        
          const isPlaceholder = variant.isPlaceholder || false;
          const isUrlImage = variant.isUrlImage || false;
          const isOriginal = variant.isOriginal || false;
          const positionLabel = variant.positionLabel || `Variant ${idx + 1}`;
          
          // Positions 0 and 1 are always the fixed URL1/URL2 drop targets (regardless of label)
          // Add special class for URL1/URL2 positions to get green background
          const isFixedPosition = idx === 0 || idx === 1;
          if (isFixedPosition) {
            card.classList.add('url-position-card');
            // Position 0 = URL1, Position 1 = URL2
            const targetPosition = idx === 0 ? 'url1' : 'url2';
            card.dataset.dropTarget = targetPosition;
            card.dataset.itemId = item.itemId;
            card.dataset.variantIndex = idx;
            card.dataset.positionIndex = idx; // Store position index for drop handling
          }
          
          // Make all cards draggable (except placeholders)
          // Fixed position cards can also be dragged to move them elsewhere
          if (!isPlaceholder) {
            card.draggable = true;
            card.dataset.variantIndex = idx;
            card.dataset.itemId = item.itemId;
            
            // Add drag handlers for all draggable cards
            card.addEventListener('dragstart', (e) => {
              e.dataTransfer.effectAllowed = 'move';
              e.dataTransfer.setData('text/plain', JSON.stringify({
                itemId: item.itemId,
                variantIndex: idx,
                variant: variant
              }));
              card.classList.add('dragging');
            });
            card.addEventListener('dragend', () => {
              card.classList.remove('dragging');
            });
          }
          
          let cardContent = '';
          if (isPlaceholder) {
            // Render placeholder
            cardContent = `
              <div class="gallery-card-image" style="position: relative;">
                <div class="placeholder-x">
                  <div class="x-icon">‚úï</div>
                  <div class="x-text">Image Not Found</div>
                </div>
              </div>
              <div class="gallery-card-body">
                <div class="gallery-card-title">${positionLabel}</div>
                <div class="gallery-card-source" style="color: var(--danger);">Failed to load</div>
              </div>
            `;
          } else {
            // Render normal image
            const isNewImage = galleryNewImages.has(item.itemId) && 
                               galleryNewImages.get(item.itemId).has(variant.originalUrl);
            const newBadgeHtml = isNewImage ? '<div class="new-images-badge">NEW</div>' : '';
            // Red badge for URL1/URL2 labels when in gallery (regardless of isOriginal flag)
            // Show red badge if positionLabel is URL1 or URL2 - this is the permanent identity
            const showRedBadge = positionLabel === 'URL1' || positionLabel === 'URL2';
            const originalBadgeHtml = showRedBadge ? `<div class="original-badge" style="position: absolute; bottom: 4px; right: 4px; background: rgba(220, 38, 38, 0.9); color: white; padding: 2px 6px; border-radius: 4px; font-size: 0.7rem; font-weight: bold; z-index: 10;">${positionLabel}</div>` : '';
            cardContent = `
              <div class="gallery-card-image" style="position: relative;">
                <img src="${variant.previewUrl || variant.originalUrl}" alt="${variant.fileName}">
                ${originalBadgeHtml}
                ${newBadgeHtml}
              </div>
              <div class="gallery-card-body">
                <div class="gallery-card-title">${positionLabel}</div>
                <div class="gallery-card-source">${variant.source || 'Unknown'}</div>
              </div>
              <button class="gallery-preview-btn" type="button">Preview</button>
            `;
          }
          
          card.innerHTML = cardContent;
          
          // Add drag and drop handlers
          // Make fixed positions (0 and 1) drop targets - these are always URL1/URL2 positions
          if (isFixedPosition) {
            // Position 0 = URL1, Position 1 = URL2
            const targetPosition = idx === 0 ? 'url1' : 'url2';
            
            // Drop target handlers for fixed positions (including placeholders)
            card.addEventListener('dragover', (e) => {
              e.preventDefault();
              e.dataTransfer.dropEffect = 'move';
              card.classList.add('drag-over');
            });
            card.addEventListener('dragleave', () => {
              card.classList.remove('drag-over');
            });
            card.addEventListener('drop', (e) => {
              e.preventDefault();
              card.classList.remove('drag-over');
              handleImageSwap(e, item.itemId, targetPosition, idx, isPlaceholder);
            });
          }
          
          if (!isPlaceholder) {
            const previewBtn = card.querySelector('.gallery-preview-btn');
            if (previewBtn) {
              previewBtn.addEventListener('click', (ev) => {
                ev.stopPropagation();
                const tempItem = { ...item, variants: fixedVariants.filter(v => !v.isPlaceholder) };
                openVariantCarousel(tempItem, idx);
              });
            }
          }
        
        fixedContainer.appendChild(card);
      });
      
      // Only create scrollable slider if there are Google images
      if (scrollableVariants.length > 0) {
        // Render scrollable variants (Google images) in track
        scrollableVariants.forEach((variant, idx) => {
          const actualIdx = idx + 2; // Offset by 2 for URL1/URL2
          const card = document.createElement('div');
          card.className = 'gallery-card';
          const currentFileName = variant.fileName;
          const isSelected = gallerySelections[uniqueKey] === currentFileName;
          if (isSelected) card.classList.add('selected');
          
          const isPlaceholder = variant.isPlaceholder || false;
          const isUrlImage = variant.isUrlImage || false;
          const isOriginal = variant.isOriginal || false;
          const positionLabel = variant.positionLabel || `Variant ${actualIdx + 1}`;
          
          // Log for debugging red badge
          if (isOriginal) {
            logToConsole(`[RENDER SCROLLABLE] Rendering scrollable variant ${idx} (actualIdx ${actualIdx}): isOriginal=${isOriginal}, positionLabel=${positionLabel}, variant.positionLabel=${variant.positionLabel}, originalUrl=${variant.originalUrl}`, 'info');
          }
          
          // Make cards draggable
          if (!isPlaceholder && !isUrlImage) {
            card.draggable = true;
            card.dataset.variantIndex = actualIdx;
            card.dataset.itemId = item.itemId;
          }
          
          let cardContent = '';
          if (isPlaceholder) {
            cardContent = `
              <div class="gallery-card-image" style="position: relative;">
                <div class="placeholder-x">
                  <div class="x-icon">‚úï</div>
                  <div class="x-text">Image Not Found</div>
                </div>
              </div>
              <div class="gallery-card-body">
                <div class="gallery-card-title">${positionLabel}</div>
                <div class="gallery-card-source" style="color: var(--danger);">Failed to load</div>
              </div>
            `;
          } else {
            const isNewImage = galleryNewImages.has(item.itemId) && 
                               galleryNewImages.get(item.itemId).has(variant.originalUrl);
            const newBadgeHtml = isNewImage ? '<div class="new-images-badge">NEW</div>' : '';
            // Red badge for URL1/URL2 labels when in gallery (regardless of isOriginal flag)
            // Show red badge if positionLabel is URL1 or URL2 - this is the permanent identity
            const showRedBadge = positionLabel === 'URL1' || positionLabel === 'URL2';
            const originalBadgeHtml = showRedBadge ? `<div class="original-badge" style="position: absolute; bottom: 4px; right: 4px; background: rgba(220, 38, 38, 0.9); color: white; padding: 2px 6px; border-radius: 4px; font-size: 0.7rem; font-weight: bold; z-index: 10;">${positionLabel}</div>` : '';
            
            // Log badge rendering
            if (showRedBadge) {
              logToConsole(`[RENDER SCROLLABLE] Creating badge for variant ${idx}: positionLabel=${positionLabel}, will render: ${originalBadgeHtml ? 'YES' : 'NO'}`, 'info');
            }
            
            cardContent = `
              <div class="gallery-card-image" style="position: relative;">
                <img src="${variant.previewUrl || variant.originalUrl}" alt="${variant.fileName}">
                ${originalBadgeHtml}
                ${newBadgeHtml}
              </div>
              <div class="gallery-card-body">
                <div class="gallery-card-title">${positionLabel}</div>
                <div class="gallery-card-source">${variant.source || 'Unknown'}</div>
              </div>
              <button class="gallery-preview-btn" type="button">Preview</button>
            `;
          }
          
          card.innerHTML = cardContent;
          
          // Add drag handlers for Google images
          if (!isPlaceholder && !isUrlImage) {
            card.addEventListener('dragstart', (e) => {
              e.dataTransfer.effectAllowed = 'move';
              e.dataTransfer.setData('text/plain', JSON.stringify({
                itemId: item.itemId,
                variantIndex: actualIdx,
                variant: variant
              }));
              card.classList.add('dragging');
            });
            card.addEventListener('dragend', () => {
              card.classList.remove('dragging');
            });
          }
          
          if (!isPlaceholder) {
            const previewBtn = card.querySelector('.gallery-preview-btn');
            if (previewBtn) {
              previewBtn.addEventListener('click', (ev) => {
                ev.stopPropagation();
                const tempItem = { ...item, variants: scrollableVariants.filter(v => !v.isPlaceholder) };
                const carouselIndex = scrollableVariants.slice(0, idx).filter(v => !v.isPlaceholder).length;
                openVariantCarousel(tempItem, carouselIndex);
              });
            }
          }
          
          track.appendChild(card);
        });
      }
      
      viewport.appendChild(track);
      rowContainer.appendChild(prevBtn);
      rowContainer.appendChild(viewport);
      rowContainer.appendChild(nextBtn);
      
      // Add fixed container before the slider
      rowContainer.insertBefore(fixedContainer, prevBtn);
      
      // Slider navigation logic - only for scrollable variants (positions 3+)
      const savedIndex = gallerySliderPositions[rowKey] || 0;
      const sliderState = { index: savedIndex, visible: 4, cardWidth: 210 };
      
      const updateSlider = () => {
        const card = track.querySelector('.gallery-card');
        if (card) {
          const cardRect = card.getBoundingClientRect();
          const cardStyle = window.getComputedStyle(card);
          const marginLeft = parseFloat(cardStyle.marginLeft) || 0;
          const marginRight = parseFloat(cardStyle.marginRight) || 0;
          sliderState.cardWidth = cardRect.width + marginLeft + marginRight;
        }
        const gap = 8;
        const viewportWidth = viewport.getBoundingClientRect().width;
        const spacePerCard = sliderState.cardWidth + gap;
        sliderState.visible = Math.max(1, Math.floor(viewportWidth / spacePerCard));
        // Only calculate pagination for scrollable variants (positions 3+)
        const lastPageBoundary = Math.floor((scrollableVariants.length - 1) / sliderState.visible) * sliderState.visible;
        const maxIndex = Math.max(0, lastPageBoundary);
        sliderState.index = Math.min(sliderState.index, maxIndex);
        sliderState.index = Math.floor(sliderState.index / sliderState.visible) * sliderState.visible;
        sliderState.index = Math.min(sliderState.index, maxIndex);
        gallerySliderPositions[rowKey] = sliderState.index;
        const offset = -spacePerCard * sliderState.index;
        
        // Disable transition if animations are disabled (for refresh)
        if (disableAnimations) {
          track.style.transition = 'none';
        }
        track.style.transform = `translateX(${offset}px)`;
        
        // Re-enable transition after render is complete if animations were disabled
        // Use a longer delay to ensure all updates are done before re-enabling
        if (disableAnimations) {
          // Don't re-enable immediately - let it stay disabled during the refresh
          // It will be re-enabled on the next user interaction (next/prev button clicks)
          // This ensures no visible transitions during refresh
        }
        const trackWidth = track.scrollWidth;
        const viewportClientWidth = viewport.clientWidth;
        const needsScrolling = trackWidth > viewportClientWidth && scrollableVariants.length > 0;
        const isAtStart = sliderState.index === 0;
        const currentOffset = -(sliderState.cardWidth + gap) * sliderState.index;
        const maxOffset = viewportClientWidth - trackWidth;
        const isAtEnd = !needsScrolling || currentOffset <= maxOffset || sliderState.index >= maxIndex;
        prevBtn.style.display = (isAtStart || !needsScrolling) ? 'none' : 'flex';
        nextBtn.style.display = (!needsScrolling || isAtEnd) ? 'none' : 'flex';
        prevBtn.disabled = isAtStart && needsScrolling;
        nextBtn.disabled = isAtEnd && needsScrolling;
        
        // Update page indicator for scrollable variants only
        const pageIndicator = rowContainer.parentElement?.querySelector('.gallery-page-indicator');
        if (pageIndicator && scrollableVariants.length > 0) {
          const currentPage = Math.floor(sliderState.index / sliderState.visible) + 1;
          const totalPages = needsScrolling ? Math.ceil(scrollableVariants.length / sliderState.visible) : 1;
          pageIndicator.textContent = `Page ${currentPage} of ${totalPages}`;
        }
      };
      
      prevBtn.addEventListener('click', () => {
        // Re-enable transitions for user interactions
        track.style.transition = '';
        const gap = 8;
        const spacePerCard = sliderState.cardWidth + gap;
        const viewportWidth = viewport.getBoundingClientRect().width;
        const visible = Math.max(1, Math.floor(viewportWidth / spacePerCard));
        sliderState.visible = visible;
        // Only calculate pagination for scrollable variants
        const lastPageBoundary = Math.floor((scrollableVariants.length - 1) / visible) * visible;
        const maxIdx = Math.max(0, lastPageBoundary);
        let newIndex = Math.max(0, sliderState.index - visible);
        newIndex = Math.floor(newIndex / visible) * visible;
        newIndex = Math.min(newIndex, maxIdx);
        sliderState.index = Math.max(0, newIndex);
        updateSlider();
      });
      
      nextBtn.addEventListener('click', () => {
        // Re-enable transitions for user interactions
        track.style.transition = '';
        const gap = 8;
        const spacePerCard = sliderState.cardWidth + gap;
        const viewportWidth = viewport.getBoundingClientRect().width;
        const visible = Math.max(1, Math.floor(viewportWidth / spacePerCard));
        sliderState.visible = visible;
        // Only calculate pagination for scrollable variants
        const lastPageBoundary = Math.floor((scrollableVariants.length - 1) / visible) * visible;
        const maxIdx = Math.max(0, lastPageBoundary);
        let newIndex = sliderState.index + visible;
        newIndex = Math.floor(newIndex / visible) * visible;
        newIndex = Math.min(newIndex, maxIdx);
        sliderState.index = newIndex;
        updateSlider();
      });
      
      window.addEventListener('resize', updateSlider);
      requestAnimationFrame(() => {
        updateSlider();
        setTimeout(updateSlider, 100);
      });
      
      return rowContainer;
    }

    // Helper function to render a URL row (URL1 or URL2) with slider (legacy, kept for compatibility)
    function renderURLRow(itemIndex, item, urlType, variants, uniqueKey) {
      const urlRowContainer = document.createElement('div');
      urlRowContainer.className = 'url-row-container';
      
      // Create label
      const label = document.createElement('div');
      label.className = 'url-row-label';
      label.textContent = urlType; // "URL1" or "URL2"
      urlRowContainer.appendChild(label);
      
      // Create slider
      const sliderWrapper = document.createElement('div');
      sliderWrapper.className = 'variant-slider';
      const prevBtn = document.createElement('button');
      prevBtn.className = 'slider-nav-btn slider-nav-prev';
      prevBtn.innerHTML = '&#8249;';
      const nextBtn = document.createElement('button');
      nextBtn.className = 'slider-nav-btn slider-nav-next';
      nextBtn.innerHTML = '&#8250;';
      const viewport = document.createElement('div');
      viewport.className = 'slider-viewport';
      const track = document.createElement('div');
      track.className = 'slider-track';
      
      // Create unique key for this URL row (itemIndex_itemId_urlType)
      const urlRowKey = `${uniqueKey}_${urlType}`;
      
      // Render variants
      variants.forEach((variant, idx) => {
        const card = document.createElement('div');
        card.className = 'gallery-card';
        const currentFileName = variant.fileName;
        const isSelected = gallerySelections[uniqueKey] === currentFileName;
        if (isSelected) card.classList.add('selected');
        
        // Check if this is a placeholder (failed URL image)
        const isPlaceholder = variant.isPlaceholder || false;
        
        let cardContent = '';
        if (isPlaceholder) {
          // Render Option 5 placeholder
          cardContent = `
            <div class="gallery-card-image" style="position: relative;">
              <div class="placeholder-x">
                <div class="x-icon">‚úï</div>
                <div class="x-text">Image Not Found</div>
              </div>
            </div>
            <div class="gallery-card-body">
              <div class="gallery-card-title">${urlType}</div>
              <div class="gallery-card-source" style="color: var(--danger);">Failed to load</div>
            </div>
          `;
        } else {
          // Render normal image
          const isNewImage = galleryNewImages.has(item.itemId) && 
                             galleryNewImages.get(item.itemId).has(variant.originalUrl);
          const newBadgeHtml = isNewImage ? '<div class="new-images-badge">NEW</div>' : '';
          cardContent = `
            <div class="gallery-card-image" style="position: relative;">
              <img src="${variant.previewUrl || variant.originalUrl}" alt="${variant.fileName}">
              ${newBadgeHtml}
            </div>
            <div class="gallery-card-body">
              <div class="gallery-card-title">${idx === 0 ? urlType : `Variant ${idx}`}</div>
              <div class="gallery-card-source">${variant.source || 'Unknown'}</div>
            </div>
            <button class="gallery-preview-btn" type="button">Preview</button>
          `;
        }
        
        card.innerHTML = cardContent;
        card.addEventListener('click', () => {
          if (!isPlaceholder) {
            toggleGallerySelection(uniqueKey, currentFileName, item.itemId);
          }
        });
        
        if (!isPlaceholder) {
          const previewBtn = card.querySelector('.gallery-preview-btn');
          if (previewBtn) {
            previewBtn.addEventListener('click', (ev) => {
              ev.stopPropagation();
              // Create a temporary item structure for carousel
              const tempItem = { ...item, variants: variants.filter(v => !v.isPlaceholder) };
              const carouselIndex = variants.slice(0, idx).filter(v => !v.isPlaceholder).length;
              openVariantCarousel(tempItem, carouselIndex);
            });
          }
        }
        
        track.appendChild(card);
      });
      
      viewport.appendChild(track);
      sliderWrapper.appendChild(prevBtn);
      sliderWrapper.appendChild(viewport);
      sliderWrapper.appendChild(nextBtn);
      
      // Slider navigation logic (simplified version)
      const savedIndex = gallerySliderPositions[urlRowKey] || 0;
      const sliderState = { index: savedIndex, visible: 4, cardWidth: 210 };
      
      const updateSlider = () => {
        const card = track.querySelector('.gallery-card');
        if (card) {
          const cardRect = card.getBoundingClientRect();
          const cardStyle = window.getComputedStyle(card);
          const marginLeft = parseFloat(cardStyle.marginLeft) || 0;
          const marginRight = parseFloat(cardStyle.marginRight) || 0;
          sliderState.cardWidth = cardRect.width + marginLeft + marginRight;
        }
        const gap = 8;
        const viewportWidth = viewport.getBoundingClientRect().width;
        const spacePerCard = sliderState.cardWidth + gap;
        sliderState.visible = Math.max(1, Math.floor(viewportWidth / spacePerCard));
        const lastPageBoundary = Math.floor((variants.length - 1) / sliderState.visible) * sliderState.visible;
        const maxIndex = Math.max(0, lastPageBoundary);
        sliderState.index = Math.min(sliderState.index, maxIndex);
        sliderState.index = Math.floor(sliderState.index / sliderState.visible) * sliderState.visible;
        sliderState.index = Math.min(sliderState.index, maxIndex);
        gallerySliderPositions[urlRowKey] = sliderState.index;
        const offset = -spacePerCard * sliderState.index;
        track.style.transform = `translateX(${offset}px)`;
        const trackWidth = track.scrollWidth;
        const viewportClientWidth = viewport.clientWidth;
        const needsScrolling = trackWidth > viewportClientWidth;
        const isAtStart = sliderState.index === 0;
        const currentOffset = -(sliderState.cardWidth + gap) * sliderState.index;
        const maxOffset = viewportClientWidth - trackWidth;
        const isAtEnd = !needsScrolling || currentOffset <= maxOffset || sliderState.index >= maxIndex;
        prevBtn.style.display = (isAtStart || !needsScrolling) ? 'none' : 'flex';
        nextBtn.style.display = (!needsScrolling || isAtEnd) ? 'none' : 'flex';
        prevBtn.disabled = isAtStart && needsScrolling;
        nextBtn.disabled = isAtEnd && needsScrolling;
      };
      
      prevBtn.addEventListener('click', () => {
        const gap = 8;
        const spacePerCard = sliderState.cardWidth + gap;
        const viewportWidth = viewport.getBoundingClientRect().width;
        const visible = Math.max(1, Math.floor(viewportWidth / spacePerCard));
        sliderState.visible = visible;
        const lastPageBoundary = Math.floor((variants.length - 1) / visible) * visible;
        const maxIdx = Math.max(0, lastPageBoundary);
        let newIndex = Math.max(0, sliderState.index - visible);
        newIndex = Math.floor(newIndex / visible) * visible;
        newIndex = Math.min(newIndex, maxIdx);
        sliderState.index = Math.max(0, newIndex);
        updateSlider();
      });
      
      nextBtn.addEventListener('click', () => {
        const gap = 8;
        const spacePerCard = sliderState.cardWidth + gap;
        const viewportWidth = viewport.getBoundingClientRect().width;
        const visible = Math.max(1, Math.floor(viewportWidth / spacePerCard));
        sliderState.visible = visible;
        const lastPageBoundary = Math.floor((variants.length - 1) / visible) * visible;
        const maxIdx = Math.max(0, lastPageBoundary);
        let newIndex = sliderState.index + visible;
        newIndex = Math.floor(newIndex / visible) * visible;
        newIndex = Math.min(newIndex, maxIdx);
        if (newIndex > sliderState.index) {
          sliderState.index = newIndex;
          updateSlider();
        }
        updateSlider();
      });
      
      window.addEventListener('resize', updateSlider);
      requestAnimationFrame(() => {
        updateSlider();
        setTimeout(updateSlider, 100);
      });
      
      urlRowContainer.appendChild(sliderWrapper);
      return urlRowContainer;
    }
    
    // Helper function to get itemId from uniqueKey
    // uniqueKey format: "itemIndex_itemId" (e.g., "0_ItemId" or "1_Item_Id")
    function getItemIdFromUniqueKey(uniqueKey) {
      const firstUnderscoreIndex = uniqueKey.indexOf('_');
      if (firstUnderscoreIndex === -1) return uniqueKey; // Fallback if no underscore
      return uniqueKey.substring(firstUnderscoreIndex + 1); // Return everything after first underscore
    }

    function toggleGallerySelection(uniqueKey, fileName, originalItemId) {
      // uniqueKey is in format: "itemIndex_itemId" to prevent collisions when items share same itemId
      const wasSelected = gallerySelections[uniqueKey] === fileName;
      
      if (wasSelected) {
        delete gallerySelections[uniqueKey];
      } else {
        gallerySelections[uniqueKey] = fileName;
        // If item was skipped, uncheck the skip checkbox (use uniqueKey)
        if (gallerySkippedItems.has(uniqueKey)) {
          gallerySkippedItems.delete(uniqueKey);
          // Need to update the skip checkbox - find the row and update it
          updateGalleryRow(uniqueKey);
        }
      }
      
      // Optimize: Update only the affected row instead of re-rendering entire gallery
      updateGalleryRow(uniqueKey);
      updateGallerySummary();
      updateGalleryToolbar();
    }
    
    // Optimized function to update only a specific row instead of re-rendering entire gallery
    // DOM cache for frequently accessed elements
    const domCache = {
      galleryGrid: null,
      getGalleryGrid: function() {
        if (!this.galleryGrid) {
          this.galleryGrid = document.getElementById('galleryGrid');
        }
        return this.galleryGrid;
      },
      clearCache: function() {
        this.galleryGrid = null;
      }
    };

    function updateGalleryRow(uniqueKey, disableAnimations = false) {
      // Parse uniqueKey to get itemIndex
      const parts = uniqueKey.split('_');
      const itemIndex = parseInt(parts[0], 10);
      if (isNaN(itemIndex) || itemIndex < 0 || itemIndex >= galleryItems.length) {
        // Fallback to full render if we can't parse the key
        logToConsole(`[UPDATE ROW] Invalid itemIndex, falling back to full render`, 'warning');
        renderGallery(disableAnimations);
        return;
      }
      
      const item = galleryItems[itemIndex];
      const grid = domCache.getGalleryGrid();
      if (!grid) {
        logToConsole(`[UPDATE ROW] Gallery grid not found, falling back to full render`, 'warning');
        renderGallery(disableAnimations);
        return;
      }
      
      const groups = grid.querySelectorAll('.gallery-group');
      if (itemIndex >= groups.length) {
        // Fallback to full render if row doesn't exist
        logToConsole(`[UPDATE ROW] Row ${itemIndex} doesn't exist, falling back to full render`, 'warning');
        renderGallery(disableAnimations);
        return;
      }
      
      const group = groups[itemIndex];
      
      // Save scroll position and slider position before re-rendering
      const savedScrollTop = grid.scrollTop;
      const savedScrollLeft = grid.scrollLeft;
      const savedSliderPosition = gallerySliderPositions[uniqueKey] || 0;
      
      // Get combined variants (URL1, URL2, Google images)
      const fixedVariants = [];
      if (item.url1Variants && item.url1Variants.length > 0) {
        fixedVariants.push(item.url1Variants[0]);
      }
      if (item.url2Variants && item.url2Variants.length > 0) {
        fixedVariants.push(item.url2Variants[0]);
      }
      const scrollableVariants = item.googleVariants || [];
      const combinedVariants = [...fixedVariants, ...scrollableVariants];
      
      // Save the header content before replacing
      const header = group.querySelector('.gallery-group-header');
      const controlsDiv = group.querySelector('.gallery-controls');
      
      // Remove the old slider content but keep header and controls
      const oldSlider = group.querySelector('.variant-slider');
      if (oldSlider) {
        oldSlider.remove();
      }
      
      // Re-render the row content
      const newSlider = renderSingleRow(itemIndex, item, combinedVariants, uniqueKey, disableAnimations);
      group.appendChild(newSlider);
      
      // Apply/remove skipped class based on current state
      const isSkipped = gallerySkippedItems.has(uniqueKey);
      if (isSkipped) {
        group.classList.add('skipped');
      } else {
        group.classList.remove('skipped');
      }
      
      // Update skip checkbox state
      const skipCheckbox = group.querySelector('.skip-checkbox');
      if (skipCheckbox) {
        skipCheckbox.checked = isSkipped;
      }
      
      // Restore scroll position
      grid.scrollTop = savedScrollTop;
      grid.scrollLeft = savedScrollLeft;
      
      // Restore slider position after a brief delay to ensure DOM is updated
      requestAnimationFrame(() => {
        const track = group.querySelector('.slider-track');
        if (track && savedSliderPosition !== undefined) {
          gallerySliderPositions[uniqueKey] = savedSliderPosition;
          updateSlider(uniqueKey, savedSliderPosition, false);
        }
      });
      
      logToConsole(`[UPDATE ROW] Successfully updated row ${itemIndex} (${item.itemId}), skipped: ${isSkipped}`, 'info');
    }

    // Handle image swap when dragging onto URL1/URL2
    function handleImageSwap(event, itemId, targetPosition, targetIndex, isPlaceholder) {
      try {
        // Save current scroll position to prevent auto-scroll (using DOM cache)
        const galleryGrid = domCache.getGalleryGrid();
        const scrollTop = galleryGrid ? galleryGrid.scrollTop : 0;
        const scrollLeft = galleryGrid ? galleryGrid.scrollLeft : 0;
        
        const dragData = JSON.parse(event.dataTransfer.getData('text/plain'));
        if (!dragData || dragData.itemId !== itemId) {
          logToConsole(`[SWAP] Invalid drag data or different item`, 'warning');
          return;
        }

        const item = galleryItems.find(i => i.itemId === itemId);
        if (!item) {
          logToConsole(`[SWAP] Item ${itemId} not found`, 'error');
          return;
        }

        const draggedVariant = dragData.variant;
        const targetArray = targetPosition === 'url1' ? item.url1Variants : item.url2Variants;
        
        // Initialize array if it doesn't exist
        if (!targetArray) {
          if (targetPosition === 'url1') {
            item.url1Variants = [];
          } else {
            item.url2Variants = [];
          }
        }
        
        // Find the dragged variant - it could be in googleVariants, url1Variants, or url2Variants
        let sourceArray = null;
        let sourceIndex = -1;
        
        // Check googleVariants first
        sourceIndex = item.googleVariants.findIndex(v => 
          v.originalUrl === draggedVariant.originalUrl || 
          v.fileName === draggedVariant.fileName
        );
        if (sourceIndex !== -1) {
          sourceArray = item.googleVariants;
          logToConsole(`[SWAP] Found dragged variant in googleVariants at index ${sourceIndex}`, 'info');
        } else {
          // Check url1Variants
          sourceIndex = item.url1Variants.findIndex(v => 
            v.originalUrl === draggedVariant.originalUrl || 
            v.fileName === draggedVariant.fileName
          );
          if (sourceIndex !== -1) {
            sourceArray = item.url1Variants;
            logToConsole(`[SWAP] Found dragged variant in url1Variants at index ${sourceIndex}`, 'info');
          } else {
            // Check url2Variants
            sourceIndex = item.url2Variants.findIndex(v => 
              v.originalUrl === draggedVariant.originalUrl || 
              v.fileName === draggedVariant.fileName
            );
            if (sourceIndex !== -1) {
              sourceArray = item.url2Variants;
              logToConsole(`[SWAP] Found dragged variant in url2Variants at index ${sourceIndex}`, 'info');
            }
          }
        }
        
        if (sourceIndex === -1 || !sourceArray) {
          logToConsole(`[SWAP] Dragged variant not found in any array`, 'warning');
          return;
        }

        if (isPlaceholder) {
          // Replace placeholder: just set the new image, don't swap
          // Preserve the dragged variant's original positionLabel - it's the permanent identity
          const draggedVariantOriginalLabel = sourceArray[sourceIndex].positionLabel || `Variant ${sourceIndex + 1}`;
          
          const newVariant = {
            ...sourceArray[sourceIndex],
            positionLabel: draggedVariantOriginalLabel // Preserve original label - NEVER change
          };
          
          if (targetArray.length === 0) {
            targetArray.push(newVariant);
          } else {
            targetArray[0] = newVariant;
          }
          // Remove the image from source array since we're using it
          sourceArray.splice(sourceIndex, 1);
          logToConsole(`[SWAP] Replaced ${targetPosition.toUpperCase()} placeholder with image, preserving label: "${draggedVariantOriginalLabel}"`, 'success');
        } else {
          // Swap: Replace URL variant with dragged variant
          const currentUrlVariant = { ...targetArray[0] };
          // Check if this is the original URL image by comparing with originalUrl1/originalUrl2
          const originalUrl = targetPosition === 'url1' ? item.originalUrl1 : item.originalUrl2;
          const isOriginalImage = originalUrl && currentUrlVariant.originalUrl === originalUrl.originalUrl;
          // Preserve isOriginal flag - use the check if flag is not set
          const preservedIsOriginal = currentUrlVariant.isOriginal !== undefined 
            ? currentUrlVariant.isOriginal 
            : isOriginalImage;
          const preservedPositionLabel = currentUrlVariant.positionLabel || (targetPosition === 'url1' ? 'URL1' : 'URL2');
          
          logToConsole(`[SWAP] Before swap - currentUrlVariant.isOriginal: ${currentUrlVariant.isOriginal}, isOriginalImage: ${isOriginalImage}, preservedIsOriginal: ${preservedIsOriginal}, preservedPositionLabel: ${preservedPositionLabel}`, 'info');
          
          // Preserve the dragged variant's original positionLabel before moving it to URL position
          // This label should NEVER change - it's the permanent identity of the image
          const draggedVariantOriginalLabel = sourceArray[sourceIndex].positionLabel || `Variant ${sourceIndex + 1}`;
          
          // Preserve the URL variant's original positionLabel - this is its permanent identity
          // If it doesn't have one yet, assign it based on position (first time only)
          const urlVariantOriginalLabel = currentUrlVariant.positionLabel || (targetPosition === 'url1' ? 'URL1' : 'URL2');
          
          // Move dragged variant to URL position, preserving its ORIGINAL positionLabel (never changes)
          targetArray[0] = { 
            ...sourceArray[sourceIndex],
            positionLabel: draggedVariantOriginalLabel // Keep original label (e.g., "Variant 4") - NEVER change
          };
          
          // If source is googleVariants, replace with old URL variant
          // If source is url1Variants or url2Variants, move old URL variant to googleVariants
          if (sourceArray === item.googleVariants) {
            // Replace in googleVariants
            item.googleVariants[sourceIndex] = { 
              ...currentUrlVariant, 
              isOriginal: preservedIsOriginal,
              positionLabel: urlVariantOriginalLabel // Preserve the ORIGINAL position label (URL1/URL2) - NEVER change
            };
            logToConsole(`[SWAP] Replaced in googleVariants at index ${sourceIndex}`, 'info');
          } else {
            // Source is url1Variants or url2Variants - remove from there and add to googleVariants
            sourceArray.splice(sourceIndex, 1);
            // Initialize googleVariants if needed
            if (!item.googleVariants) {
              item.googleVariants = [];
            }
            // Add to googleVariants, preserving position label
            item.googleVariants.push({
              ...currentUrlVariant,
              isOriginal: preservedIsOriginal,
              positionLabel: urlVariantOriginalLabel
            });
            logToConsole(`[SWAP] Moved from ${sourceArray === item.url1Variants ? 'url1Variants' : 'url2Variants'} to googleVariants`, 'info');
          }
          
          logToConsole(`[SWAP] Label preservation - dragged variant keeps: "${draggedVariantOriginalLabel}", URL variant keeps: "${urlVariantOriginalLabel}"`, 'info');
          logToConsole(`[SWAP] Swapped ${targetPosition.toUpperCase()} with image from ${sourceArray === item.googleVariants ? 'googleVariants' : (sourceArray === item.url1Variants ? 'url1Variants' : 'url2Variants')}`, 'success');
        }
        
        // Update isOriginal flag for new URL position (always false since it's a new image)
        targetArray[0].isOriginal = false; // New image is not original
        
        // Update only the affected row instead of re-rendering entire gallery
        const targetItemIndex = galleryItems.findIndex(i => i.itemId === itemId);
        const targetUniqueKey = getUniqueKey(targetItemIndex, itemId);
        updateGalleryRow(targetUniqueKey, true); // Disable animations
        
        // Update toolbar and summary after drag/drop to reflect new state
        updateGalleryToolbar();
        updateGallerySummary();
      } catch (error) {
        logToConsole(`[SWAP] Error: ${error.message}`, 'error');
      }
    }

    // Reset URL1/URL2 to original images
    function resetItemUrls(itemId) {
      try {
        const item = galleryItems.find(i => i.itemId === itemId);
        if (!item) {
          logToConsole(`[RESET] Item ${itemId} not found`, 'error');
          return;
        }

        // Save scroll position before reset (using DOM cache)
        const grid = domCache.getGalleryGrid();
        const savedScrollTop = grid ? grid.scrollTop : 0;
        
        // Initialize googleVariants if it doesn't exist
        if (!item.googleVariants) {
          item.googleVariants = [];
        }
        
        // Reset URL1: Find original URL1 (might be in url1Variants or googleVariants)
        if (item.originalUrl1) {
          const currentUrl1 = item.url1Variants && item.url1Variants.length > 0 ? item.url1Variants[0] : null;
          
          // Find original URL1 - it might be in url1Variants[0] or in googleVariants
          const originalUrl1InGoogle = item.googleVariants.findIndex(v => 
            v.originalUrl === item.originalUrl1.originalUrl || 
            v.fileName === item.originalUrl1.fileName
          );
          
          // If current URL1 is not the original, move it to googleVariants
          if (currentUrl1 && currentUrl1.originalUrl !== item.originalUrl1.originalUrl) {
            // Check if it's already in googleVariants to avoid duplicates
            const currentUrl1InGoogle = item.googleVariants.findIndex(v => 
              v.originalUrl === currentUrl1.originalUrl || v.fileName === currentUrl1.fileName
            );
            if (currentUrl1InGoogle === -1) {
              item.googleVariants.push(currentUrl1);
              logToConsole(`[RESET] Moved current URL1 (${currentUrl1.positionLabel}) to googleVariants`, 'info');
            }
          }
          
          // Remove original URL1 from googleVariants if it's there
          if (originalUrl1InGoogle !== -1) {
            item.googleVariants.splice(originalUrl1InGoogle, 1);
            logToConsole(`[RESET] Removed original URL1 from googleVariants`, 'info');
          }
          
          // Set URL1 to original
          item.url1Variants = [{ 
            ...item.originalUrl1,
            positionLabel: 'URL1' // Permanent label
          }];
          logToConsole(`[RESET] Set URL1 to original: ${item.originalUrl1.originalUrl}`, 'info');
        } else {
          // No original URL1 - create placeholder
          const currentUrl1 = item.url1Variants && item.url1Variants.length > 0 ? item.url1Variants[0] : null;
          
          // If there's a current URL1 that's not a placeholder, move it to googleVariants
          if (currentUrl1 && !currentUrl1.isPlaceholder) {
            const currentUrl1InGoogle = item.googleVariants.findIndex(v => 
              v.originalUrl === currentUrl1.originalUrl || v.fileName === currentUrl1.fileName
            );
            if (currentUrl1InGoogle === -1) {
              item.googleVariants.push(currentUrl1);
              logToConsole(`[RESET] Moved current URL1 (${currentUrl1.positionLabel}) to googleVariants`, 'info');
            }
          }
          
          // Create placeholder for URL1
          item.url1Variants = [{
            fileName: 'URL1_placeholder',
            previewUrl: '',
            originalUrl: '_PLACEHOLDER_',
            source: 'URL1',
            shortDescription: '',
            description: '',
            isPlaceholder: true,
            positionLabel: 'URL1',
            isUrlImage: true
          }];
          logToConsole(`[RESET] Set URL1 to placeholder (no original)`, 'info');
        }

        // Reset URL2: Same logic as URL1
        if (item.originalUrl2) {
          const currentUrl2 = item.url2Variants && item.url2Variants.length > 0 ? item.url2Variants[0] : null;
          
          // Find original URL2 - it might be in url2Variants[0] or in googleVariants
          const originalUrl2InGoogle = item.googleVariants.findIndex(v => 
            v.originalUrl === item.originalUrl2.originalUrl || 
            v.fileName === item.originalUrl2.fileName
          );
          
          // If current URL2 is not the original, move it to googleVariants
          if (currentUrl2 && currentUrl2.originalUrl !== item.originalUrl2.originalUrl) {
            const currentUrl2InGoogle = item.googleVariants.findIndex(v => 
              v.originalUrl === currentUrl2.originalUrl || v.fileName === currentUrl2.fileName
            );
            if (currentUrl2InGoogle === -1) {
              item.googleVariants.push(currentUrl2);
              logToConsole(`[RESET] Moved current URL2 (${currentUrl2.positionLabel}) to googleVariants`, 'info');
            }
          }
          
          // Remove original URL2 from googleVariants if it's there
          if (originalUrl2InGoogle !== -1) {
            item.googleVariants.splice(originalUrl2InGoogle, 1);
            logToConsole(`[RESET] Removed original URL2 from googleVariants`, 'info');
          }
          
          // Set URL2 to original
          item.url2Variants = [{ 
            ...item.originalUrl2,
            positionLabel: 'URL2' // Permanent label
          }];
          logToConsole(`[RESET] Set URL2 to original: ${item.originalUrl2.originalUrl}`, 'info');
        } else {
          // No original URL2 - create placeholder
          const currentUrl2 = item.url2Variants && item.url2Variants.length > 0 ? item.url2Variants[0] : null;
          
          // If there's a current URL2 that's not a placeholder, move it to googleVariants
          if (currentUrl2 && !currentUrl2.isPlaceholder) {
            const currentUrl2InGoogle = item.googleVariants.findIndex(v => 
              v.originalUrl === currentUrl2.originalUrl || v.fileName === currentUrl2.fileName
            );
            if (currentUrl2InGoogle === -1) {
              item.googleVariants.push(currentUrl2);
              logToConsole(`[RESET] Moved current URL2 (${currentUrl2.positionLabel}) to googleVariants`, 'info');
            }
          }
          
          // Create placeholder for URL2
          item.url2Variants = [{
            fileName: 'URL2_placeholder',
            previewUrl: '',
            originalUrl: '_PLACEHOLDER_',
            source: 'URL2',
            shortDescription: '',
            description: '',
            isPlaceholder: true,
            positionLabel: 'URL2',
            isUrlImage: true
          }];
          logToConsole(`[RESET] Set URL2 to placeholder (no original)`, 'info');
        }

        logToConsole(`[RESET] Reset URL1 and URL2 for ${itemId}`, 'success');
        
        // Sort googleVariants by positionLabel number (Variant 1, Variant 2, etc.) WITHOUT changing labels
        // This ensures Variant 1 appears first, Variant 2 second, etc. in positions 3+
        // Filter out any URL1/URL2 labels that shouldn't be in googleVariants
        const variantsToSort = item.googleVariants.filter(v => 
          v.positionLabel !== 'URL1' && v.positionLabel !== 'URL2'
        );
        
        // Sort by extracting number from positionLabel (e.g., "Variant 1" -> 1, "Variant 2" -> 2)
        variantsToSort.sort((a, b) => {
          const getVariantNumber = (variant) => {
            if (variant.positionLabel) {
              const match = variant.positionLabel.match(/^Variant (\d+)$/);
              if (match) {
                return parseInt(match[1], 10);
              }
            }
            // If no positionLabel or doesn't match pattern, sort to end
            return 9999;
          };
          return getVariantNumber(a) - getVariantNumber(b);
        });
        
        // Update googleVariants with sorted array (labels remain unchanged)
        item.googleVariants = variantsToSort;
        
        logToConsole(`[RESET] Sorted ${variantsToSort.length} variants by positionLabel for ${itemId}`, 'info');
        
        // Update only the affected row instead of re-rendering entire gallery
        const targetItemIndex = galleryItems.findIndex(i => i.itemId === itemId);
        const targetUniqueKey = getUniqueKey(targetItemIndex, itemId);
        updateGalleryRow(targetUniqueKey, true); // Disable animations
        
        // Update toolbar and summary after reset to reflect new state
        updateGalleryToolbar();
        updateGallerySummary();
      } catch (error) {
        logToConsole(`[RESET] Error: ${error.message}`, 'error');
      }
    }

    function selectFirstVariants() {
      logToConsole('[SELECT FIRST] Starting selectFirstVariants...', 'info');
      
      galleryItems.forEach((item, itemIndex) => {
        const uniqueKey = getUniqueKey(itemIndex, item.itemId);
        
        // Skip items that are already marked as skipped
        if (gallerySkippedItems.has(uniqueKey)) {
          logToConsole(`[SELECT FIRST] Skipping already skipped item ${item.itemId}`, 'info');
          return;
        }
        
        // Initialize arrays if needed
        if (!item.url1Variants) item.url1Variants = [];
        if (!item.url2Variants) item.url2Variants = [];
        if (!item.googleVariants) item.googleVariants = [];
        
        // Check for placeholders
        const url1Variant = item.url1Variants.length > 0 ? item.url1Variants[0] : null;
        const url2Variant = item.url2Variants.length > 0 ? item.url2Variants[0] : null;
        const url1IsPlaceholder = !url1Variant || url1Variant.isPlaceholder || url1Variant.originalUrl === '_PLACEHOLDER_';
        const url2IsPlaceholder = !url2Variant || url2Variant.isPlaceholder || url2Variant.originalUrl === '_PLACEHOLDER_';
        
        // Count how many variants we need
        const placeholdersNeeded = (url1IsPlaceholder ? 1 : 0) + (url2IsPlaceholder ? 1 : 0);
        
        // If no placeholders, nothing to do
        if (placeholdersNeeded === 0) {
          logToConsole(`[SELECT FIRST] Item ${item.itemId} has no placeholders, skipping`, 'info');
          return;
        }
        
        // Check if we have enough variants
        if (item.googleVariants.length < placeholdersNeeded) {
          logToConsole(`[SELECT FIRST] Item ${item.itemId} has only ${item.googleVariants.length} variants but needs ${placeholdersNeeded}, auto-skipping`, 'warning');
          gallerySkippedItems.add(uniqueKey);
          // Clear selection if item is skipped
          delete gallerySelections[uniqueKey];
          // Update the row to show it's skipped
          updateGalleryRow(uniqueKey);
          return;
        }
        
        // Fill URL1 placeholder if needed
        if (url1IsPlaceholder && item.googleVariants.length > 0) {
          const variantToMove = item.googleVariants[0];
          const variantLabel = variantToMove.positionLabel || 'Variant 1';
          
          // Move variant to URL1 position, preserving its original label
          item.url1Variants[0] = {
            ...variantToMove,
            positionLabel: variantLabel // Preserve original label (e.g., "Variant 1")
          };
          
          // Remove from googleVariants
          item.googleVariants.splice(0, 1);
          
          logToConsole(`[SELECT FIRST] Moved ${variantLabel} to URL1 for ${item.itemId}`, 'info');
        }
        
        // Fill URL2 placeholder if needed
        if (url2IsPlaceholder && item.googleVariants.length > 0) {
          const variantToMove = item.googleVariants[0];
          const variantLabel = variantToMove.positionLabel || 'Variant 2';
          
          // Move variant to URL2 position, preserving its original label
          item.url2Variants[0] = {
            ...variantToMove,
            positionLabel: variantLabel // Preserve original label (e.g., "Variant 2")
          };
          
          // Remove from googleVariants
          item.googleVariants.splice(0, 1);
          
          logToConsole(`[SELECT FIRST] Moved ${variantLabel} to URL2 for ${item.itemId}`, 'info');
        }
        
        // Update only this row (performance optimization)
        updateGalleryRow(uniqueKey);
      });
      
      // Update toolbar and summary after all rows are processed
      updateGalleryToolbar();
      updateGallerySummary();
      
      logToConsole('[SELECT FIRST] selectFirstVariants completed', 'success');
    }

    function openVariantCarousel(group, startIndex) {
      carouselGroup = group;
      carouselIndex = startIndex;
      updateCarouselView();
      document.getElementById('carouselModal').classList.add('show');
    }

    function closeVariantCarousel() {
      document.getElementById('carouselModal').classList.remove('show');
      carouselGroup = null;
      carouselIndex = 0;
    }

    function updateCarouselView() {
      if (!carouselGroup) return;
      const variant = carouselGroup.variants[carouselIndex];
      if (!variant) return;
      document.getElementById('carouselTitle').textContent = carouselGroup.productName || carouselGroup.itemId;
      const imgEl = document.getElementById('carouselImage');
      imgEl.src = variant.originalUrl || variant.previewUrl;
      imgEl.alt = variant.fileName;
      document.getElementById('carouselVariantLabel').textContent = `Variant ${carouselIndex + 1} ‚Ä¢ Source: ${variant.source || 'Unknown'}`;
      const originalLink = document.getElementById('carouselOpenOriginal');
      originalLink.href = variant.originalUrl;
    }

    function shiftCarousel(delta) {
      if (!carouselGroup) return;
      const total = carouselGroup.variants.length;
      if (total === 0) return;
      carouselIndex = (carouselIndex + delta + total) % total;
      updateCarouselView();
    }

    function useCarouselImage() {
      if (!carouselGroup) return;
      const variant = carouselGroup.variants[carouselIndex];
      if (!variant) return;
      // Find the itemIndex for carouselGroup to create unique key
      const itemIndex = galleryItems.findIndex(item => item.itemId === carouselGroup.itemId && item === carouselGroup);
      let uniqueKey;
      if (itemIndex === -1) {
        // Fallback: search by itemId (might have duplicates, use first match)
        const foundIndex = galleryItems.findIndex(item => item.itemId === carouselGroup.itemId);
        if (foundIndex === -1) {
          // Can't find the item, just close and return
          closeVariantCarousel();
          return;
        }
        uniqueKey = getUniqueKey(foundIndex, carouselGroup.itemId);
        gallerySelections[uniqueKey] = variant.fileName;
      } else {
        uniqueKey = getUniqueKey(itemIndex, carouselGroup.itemId);
        gallerySelections[uniqueKey] = variant.fileName;
      }
      
      // Calculate which page contains the selected variant and scroll to it
      // Estimate visible count (will be recalculated accurately after render)
      const estimatedVisible = 5;
      const variantIndex = carouselIndex; // 0-based index of the selected variant
      
      // Calculate target page index: align variant index to page boundary
      // Example: variant 7 (index 6) with 5 visible -> page index = floor(6/5)*5 = 5 (shows variants 6-10)
      let targetIndex = Math.floor(variantIndex / estimatedVisible) * estimatedVisible;
      
      // Calculate maxIndex (last page boundary) for clamping
      const lastPageBoundary = Math.floor((carouselGroup.variants.length - 1) / estimatedVisible) * estimatedVisible;
      const maxIdx = Math.max(0, lastPageBoundary);
      targetIndex = Math.min(targetIndex, maxIdx);
      
      // Save slider position BEFORE updateGalleryRow() so the row scrolls to the correct page
      gallerySliderPositions[uniqueKey] = targetIndex;
      
      // Save values before closing carousel (carouselGroup will be nulled)
      const savedItemIndex = itemIndex !== -1 ? itemIndex : galleryItems.findIndex(item => item.itemId === carouselGroup.itemId);
      const savedVariantIndex = carouselIndex;
      const savedVariantsLength = carouselGroup.variants.length;
      
      // Update only the affected row instead of re-rendering entire gallery
      updateGalleryRow(uniqueKey);
      closeVariantCarousel();
      
      // Fine-tune scroll position after render with accurate measurements
      // Use requestAnimationFrame to ensure DOM is fully rendered
      requestAnimationFrame(() => {
        setTimeout(() => {
          const item = galleryItems[savedItemIndex];
          if (!item) return;
          
          const group = document.querySelector(`.gallery-group[data-item-index="${savedItemIndex}"]`);
          if (!group) return;
          
          const viewport = group.querySelector('.variant-slider');
          const track = group.querySelector('.slider-track');
          if (!viewport || !track) return;
          
          // Recalculate with accurate measurements
          const gap = 8; // Match slider-track gap (0.5rem = 8px)
          const firstCard = track.querySelector('.gallery-card');
          if (!firstCard) return;
          const cardWidth = firstCard.getBoundingClientRect().width;
          const spacePerCard = cardWidth + gap;
          const viewportWidth = viewport.getBoundingClientRect().width;
          const visible = Math.max(1, Math.floor(viewportWidth / spacePerCard));
          
          // Recalculate target index with accurate visible count
          const accurateTargetIndex = Math.floor(savedVariantIndex / visible) * visible;
          const accurateLastPageBoundary = Math.floor((item.variants.length - 1) / visible) * visible;
          const accurateMaxIdx = Math.max(0, accurateLastPageBoundary);
          const finalIndex = Math.min(accurateTargetIndex, accurateMaxIdx);
          
          // Update saved position
          gallerySliderPositions[uniqueKey] = finalIndex;
          
          // Update the slider state and apply transform
          const sliderState = group._sliderState;
          if (sliderState) {
            sliderState.index = finalIndex;
            sliderState.visible = visible;
            sliderState.cardWidth = cardWidth;
            
            const offset = -spacePerCard * finalIndex;
            track.style.transform = `translateX(${offset}px)`;
            
            // Update arrows and page indicator
            const updateSlider = group._updateSlider;
            if (updateSlider) updateSlider();
          }
        }, 100);
      });
    }

    function setGalleryStatus(message) {
      document.getElementById('galleryFooterStatus').textContent = message || '';
    }

    function refreshGallery() {
      // Save scroll position before refresh
      const grid = domCache.getGalleryGrid();
      const savedScrollTop = grid ? grid.scrollTop : 0;
      
      setGalleryStatus('Resetting all rows and clearing skipped items...');
      logToConsole('[REFRESH] Refreshing gallery by resetting all rows and clearing skipped items', 'info');
      
      // Clear all skipped items
      gallerySkippedItems.clear();
      logToConsole('[REFRESH] Cleared all skipped items', 'info');
      
      // Simply call resetItemUrls for each row - no other logic needed
      galleryItems.forEach((item) => {
        resetItemUrls(item.itemId);
      });
      
      setGalleryStatus('All rows reset');
      logToConsole(`[REFRESH] Reset ${galleryItems.length} rows and cleared skipped items`, 'success');
      
      // Restore scroll position after render
      if (grid) {
        requestAnimationFrame(() => {
          grid.scrollTop = savedScrollTop;
        });
      }
    }

    async function handleRefreshImages(itemId, refreshBtn) {
      logToConsole(`[REFRESH] handleRefreshImages called for itemId: ${itemId}`, 'info');
      
      if (!lastGalleryPayload) {
        logToConsole('[REFRESH] ERROR: No previous gallery data available', 'error');
        setGalleryStatus('Error: No previous gallery data available');
        return;
      }

      const item = galleryItems.find(i => i.itemId === itemId);
      if (!item) {
        logToConsole(`[REFRESH] ERROR: Item ${itemId} not found in galleryItems`, 'error');
        setGalleryStatus(`Error: Item ${itemId} not found`);
        return;
      }

      // Get existing Google image URLs to avoid duplicates
      const existingGoogleUrls = new Set((item.googleVariants || []).map(v => v.originalUrl));
      const currentGoogleCount = (item.googleVariants || []).length;
      logToConsole(`[REFRESH] Current Google images: ${currentGoogleCount}, existing URLs: ${existingGoogleUrls.size}`, 'info');

      refreshBtn.classList.add('loading');
      refreshBtn.disabled = true;
      setGalleryStatus(`Fetching 3 new images for ${getItemDisplayLabel(itemId)}...`);
      logToConsole(`[REFRESH] Starting fetch for 3 new Google images...`, 'info');

      try {
        // Find the original POS item in the payload
        const originalPosItems = lastGalleryPayload.posItems || [];
        const originalItem = originalPosItems.find(p => p.itemId === itemId);
        
        if (!originalItem) {
          logToConsole(`[REFRESH] ERROR: Item ${itemId} not found in original posItems`, 'error');
          setGalleryStatus(`Error: Item ${itemId} not found in original data`);
          return;
        }

        const shortDescription = originalItem.shortDescription || itemId;
        logToConsole(`[REFRESH] Using ShortDescription: '${shortDescription}'`, 'info');
        
        // Calculate start index based on current Google images count
        // Start from position after existing Google images
        const startIndex = currentGoogleCount + 1; // 1-based index
        logToConsole(`[REFRESH] Start index: ${startIndex} (current Google count: ${currentGoogleCount})`, 'info');
        
        // Create payload for single item with 3 new images
        const singleItemPayload = {
          ...lastGalleryPayload,
          posItems: [originalItem], // Send only this one item
          images_per_item: 3, // Request exactly 3 new images
          start_index: startIndex // Start from next position
        };

        logToConsole(`[REFRESH] Calling gallery_generate API with single item...`, 'info');
        const result = await apiCall('gallery_generate', singleItemPayload);

        if (!result.success) {
          logToConsole(`[REFRESH] API Error: ${result.error}`, 'error');
          setGalleryStatus(`Error fetching new images: ${result.error || 'Unknown error'}`);
          return;
        }

        const newItems = result.items || [];
        logToConsole(`[REFRESH] API returned ${newItems.length} items`, 'info');
        
        if (newItems.length === 0) {
          logToConsole(`[REFRESH] No items returned from API`, 'warning');
          setGalleryStatus(`No new images found for ${getItemDisplayLabel(itemId)}`);
          return;
        }
        
        const returnedItem = newItems[0];
        if (returnedItem.itemId !== itemId) {
          logToConsole(`[REFRESH] WARNING: ItemId mismatch - returned: ${returnedItem.itemId}, expected: ${itemId}`, 'warning');
        }

        const newGoogleVariants = returnedItem.googleVariants || [];
        logToConsole(`[REFRESH] Received ${newGoogleVariants.length} new Google variants`, 'info');
        
        // Filter out duplicates by comparing image URLs
        const uniqueNewVariants = newGoogleVariants.filter(v => !existingGoogleUrls.has(v.originalUrl));
        logToConsole(`[REFRESH] After duplicate filter: ${uniqueNewVariants.length} unique variants`, 'info');

        if (uniqueNewVariants.length === 0) {
          logToConsole(`[REFRESH] No unique new images (all ${newGoogleVariants.length} were duplicates)`, 'warning');
          setGalleryStatus(`No new unique images found for ${getItemDisplayLabel(itemId)} (all ${newGoogleVariants.length} were duplicates)`);
          return;
        }

        // Limit to 3 images (take first 3 unique ones)
        const variantsToAdd = uniqueNewVariants.slice(0, 3);
        logToConsole(`[REFRESH] Adding ${variantsToAdd.length} new Google images to item`, 'info');
        
        // Add new variants to the item's googleVariants array
        if (!item.googleVariants) {
          item.googleVariants = [];
        }
        
        // Find the highest existing Variant number to continue numbering from there
        let maxVariantNumber = 0;
        item.googleVariants.forEach(variant => {
          const label = variant.positionLabel || '';
          // Only count "Variant X" labels, ignore URL1/URL2
          if (label !== 'URL1' && label !== 'URL2') {
            const match = label.match(/^Variant (\d+)$/);
            if (match) {
              const variantNum = parseInt(match[1], 10);
              if (variantNum > maxVariantNumber) {
                maxVariantNumber = variantNum;
              }
            }
          }
        });
        
        // Assign permanent labels to new variants, continuing from highest existing number
        variantsToAdd.forEach((variant, idx) => {
          const variantNumber = maxVariantNumber + idx + 1;
          variant.positionLabel = `Variant ${variantNumber}`; // Permanent label - assigned once, never changes
        });
        
        item.googleVariants.push(...variantsToAdd);
        logToConsole(`[REFRESH] Item now has ${item.googleVariants.length} Google images total. New variants labeled: ${variantsToAdd.map(v => v.positionLabel).join(', ')}`, 'success');
        
        // Calculate first new image index in combined array: URL1 (0), URL2 (1), then Google images (2+)
        const firstNewImageIndex = 2 + currentGoogleCount; // 2 = URL1 + URL2 positions

        // Track new images for badge display
        if (!galleryNewImages.has(itemId)) {
          galleryNewImages.set(itemId, new Set());
        }
        variantsToAdd.forEach(v => {
          galleryNewImages.get(itemId).add(v.originalUrl);
        });

        // Calculate target index BEFORE renderGallery() so the new slider is created with correct position
        // Estimate visible count (will be recalculated after render, but this gives us a starting point)
        // Use a reasonable estimate: typically 5-6 cards fit, but we'll use 5 as a safe estimate
        const estimatedVisible = 5;
        const targetIndex = firstNewImageIndex;
        
        // Calculate total variants count (URL1 + URL2 + Google images)
        const totalVariants = 2 + item.googleVariants.length; // 2 = URL1 + URL2
        
        // Calculate maxIndex (last page boundary) for alignment
        const lastPageBoundary = Math.floor((totalVariants - 1) / estimatedVisible) * estimatedVisible;
        const maxIdx = Math.max(0, lastPageBoundary);
        
        // Align target index to page boundary (multiple of visible) to ensure proper page alignment
        // This ensures we show variant 1, 6, 11, etc. in the leftmost position
        let finalIndex = targetIndex;
        // Align to the nearest page boundary (round down to ensure we don't overshoot)
        finalIndex = Math.floor(finalIndex / estimatedVisible) * estimatedVisible;
        // Clamp to maxIdx (which is already a page boundary)
        finalIndex = Math.min(finalIndex, maxIdx);
        
        // Update saved position BEFORE updateGalleryRow() so the new slider uses the correct position
        const targetItemIndex = galleryItems.findIndex(i => i.itemId === itemId);
        const uniqueKey = getUniqueKey(targetItemIndex, itemId);
        gallerySliderPositions[uniqueKey] = finalIndex;
        
        setGalleryStatus(`Added ${variantsToAdd.length} new image(s) for ${getItemDisplayLabel(itemId)}${uniqueNewVariants.length > 3 ? ` (${uniqueNewVariants.length - 3} more available)` : ''}`);
        
        // Update only the affected row instead of re-rendering entire gallery
        updateGalleryRow(uniqueKey, true); // Disable animations when refreshing
        
        // After render, fine-tune the position with accurate measurements
        // Use requestAnimationFrame + setTimeout to ensure DOM is fully rendered and slider is initialized
        requestAnimationFrame(() => {
          setTimeout(() => {
            const grid = domCache.getGalleryGrid();
            const groups = grid ? grid.querySelectorAll('.gallery-group') : [];
            
            if (targetItemIndex >= 0 && targetItemIndex < groups.length) {
              const group = groups[targetItemIndex];
              const track = group.querySelector('.slider-track');
              const viewport = group.querySelector('.slider-viewport');
              
              if (track && viewport) {
                const card = track.querySelector('.gallery-card');
                if (card) {
                  const cardRect = card.getBoundingClientRect();
                  const cardStyle = window.getComputedStyle(card);
                  const marginLeft = parseFloat(cardStyle.marginLeft) || 0;
                  const marginRight = parseFloat(cardStyle.marginRight) || 0;
                  const cardWidth = cardRect.width + marginLeft + marginRight;
                  const gap = 8; // Match slider-track gap
                  const spacePerCard = cardWidth + gap;
                  const viewportWidth = viewport.getBoundingClientRect().width;
                  const visible = Math.max(1, Math.floor(viewportWidth / spacePerCard));
                  
                  // Recalculate with accurate measurements
                  // Calculate total variants count (URL1 + URL2 + Google images)
                  const accurateTotalVariants = 2 + item.googleVariants.length; // 2 = URL1 + URL2
                  
                  // Calculate maxIndex (last page boundary) for alignment
                  const lastPageBoundary = Math.floor((accurateTotalVariants - 1) / visible) * visible;
                  const accurateMaxIndex = Math.max(0, lastPageBoundary);
                  
                  // Align to page boundary with accurate visible count
                  let accurateFinalIndex = firstNewImageIndex;
                  // Align to the nearest page boundary (round down to ensure we don't overshoot)
                  accurateFinalIndex = Math.floor(accurateFinalIndex / visible) * visible;
                  // Clamp to maxIndex (which is already a page boundary)
                  accurateFinalIndex = Math.min(accurateFinalIndex, accurateMaxIndex);
                  
                  // Update saved position with accurate calculation
                  gallerySliderPositions[uniqueKey] = accurateFinalIndex;
                  
                  // Manually set the transform to ensure it's applied immediately (no animation)
                  const offset = -spacePerCard * accurateFinalIndex;
                  track.style.transition = 'none'; // Disable transition for instant scroll
                  track.style.transform = `translateX(${offset}px)`;
                  track.offsetHeight; // Force reflow
                  track.style.transition = ''; // Re-enable transition
                  
                  // Trigger updateSlider to sync the sliderState with the new position
                  setTimeout(() => {
                    window.dispatchEvent(new Event('resize'));
                  }, 50);
                  
                  // Update arrow visibility and page indicator
                  const prevBtn = group.querySelector('.slider-nav-prev');
                  const nextBtn = group.querySelector('.slider-nav-next');
                  const trackWidth = track.scrollWidth;
                  const needsScrolling = trackWidth > viewportWidth;
                  const isAtStart = accurateFinalIndex === 0;
                  const isAtEnd = !needsScrolling || accurateFinalIndex >= accurateMaxIndex;
                  
                  if (prevBtn) {
                    prevBtn.style.display = (isAtStart || !needsScrolling) ? 'none' : 'flex';
                    prevBtn.disabled = isAtStart && needsScrolling;
                  }
                  if (nextBtn) {
                    nextBtn.style.display = (!needsScrolling || isAtEnd) ? 'none' : 'flex';
                    nextBtn.disabled = isAtEnd && needsScrolling;
                  }
                  
                  // Update page indicator after scrolling to new images
                  const currentPage = Math.floor(accurateFinalIndex / visible) + 1;
                  const totalPages = needsScrolling ? Math.ceil(accurateTotalVariants / visible) : 1;
                  const pageIndicator = group.querySelector('.gallery-page-indicator');
                  if (pageIndicator) {
                    pageIndicator.textContent = `Page ${currentPage} of ${totalPages}`;
                  }
                }
              }
            }
          }, 100); // Small delay to ensure slider is fully initialized
        });
      } catch (error) {
        setGalleryStatus(`Error: ${error.message || 'Unknown error'}`);
      } finally {
        refreshBtn.classList.remove('loading');
        refreshBtn.disabled = false;
      }
    }

    function getGalleryRequiredItems() {
      return galleryItems
        .filter((item, itemIndex) => {
          const uniqueKey = getUniqueKey(itemIndex, item.itemId);
          return item.variants.length > 0 && !gallerySkippedItems.has(uniqueKey);
        })
        .map(item => item.itemId);
    }

    function parseCsvToArray(csvText) {
      const rows = csvText.split(/\r?\n/).filter(Boolean);
      return rows.slice(1).map(row => row.split(','));
    }

    // Helper function to download an image from a URL
    async function downloadImage(url, filename) {
      try {
        logToConsole(`[DOWNLOAD] Starting download: ${filename} from ${url}`, 'info');
        const response = await fetch(url);
        if (!response.ok) {
          throw new Error(`Failed to fetch image: ${response.status} ${response.statusText}`);
        }
        const blob = await response.blob();
        
        // Create a temporary link and trigger download
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        // Clean up the object URL after a delay
        setTimeout(() => URL.revokeObjectURL(link.href), 100);
        
        logToConsole(`[DOWNLOAD] Successfully downloaded: ${filename}`, 'success');
      } catch (error) {
        logToConsole(`[DOWNLOAD] Error downloading ${filename}: ${error.message}`, 'error');
        throw error;
      }
    }

    async function finalizeGallerySelections() {
      // Check that every row has images in positions 1 and 2 (or is skipped)
      const missing = [];
      galleryItems.forEach((item, itemIndex) => {
        const uniqueKey = getUniqueKey(itemIndex, item.itemId);
        const isSkipped = gallerySkippedItems.has(uniqueKey);
        
        // Skip items that are marked as skipped
        if (isSkipped) return;
        
        // Check if position 1 (URL1) has an image (not a placeholder)
        const url1Variant = item.url1Variants && item.url1Variants.length > 0 ? item.url1Variants[0] : null;
        const hasUrl1 = url1Variant && !url1Variant.isPlaceholder && url1Variant.originalUrl !== '_PLACEHOLDER_';
        
        // Check if position 2 (URL2) has an image (not a placeholder)
        const url2Variant = item.url2Variants && item.url2Variants.length > 0 ? item.url2Variants[0] : null;
        const hasUrl2 = url2Variant && !url2Variant.isPlaceholder && url2Variant.originalUrl !== '_PLACEHOLDER_';
        
        if (!hasUrl1 || !hasUrl2) {
          missing.push(item.itemId);
        }
      });

      if (missing.length > 0) {
        const missingLabels = missing.map(getItemDisplayLabel);
        setGalleryStatus(`Missing images in positions 1 or 2 for: ${missingLabels.join(', ')}`);
        updateGalleryWarnings();
        return;
      }

      galleryLoading = true;
      updateGalleryToolbar();
      setGalleryStatus('Creating zip file with images from positions 1 and 2...');

      try {
        // Create a zip file with images from positions 1 and 2 for each item
        const zip = new JSZip();
        const imagePromises = [];
        
        galleryItems.forEach((item, itemIndex) => {
          const uniqueKey = getUniqueKey(itemIndex, item.itemId);
          const isSkipped = gallerySkippedItems.has(uniqueKey);
          
          // Skip items that are marked as skipped
          if (isSkipped) return;
          
          // Download position 1 (URL1) image
          const url1Variant = item.url1Variants && item.url1Variants.length > 0 ? item.url1Variants[0] : null;
          if (url1Variant && !url1Variant.isPlaceholder && url1Variant.originalUrl !== '_PLACEHOLDER_') {
            const filename1 = `${item.itemId}_1`;
            // Get file extension from URL or default to .jpg
            const urlExt = url1Variant.originalUrl.match(/\.(jpg|jpeg|png|gif|webp)(\?|$)/i);
            const ext = urlExt ? urlExt[1] : 'jpg';
            const fullFilename1 = `${filename1}.${ext}`;
            
            imagePromises.push(
              fetch(url1Variant.originalUrl)
                .then(response => response.blob())
                .then(blob => {
                  zip.file(fullFilename1, blob);
                  logToConsole(`[ZIP] Added ${item.itemId} position 1: ${fullFilename1}`, 'info');
                })
                .catch(error => {
                  logToConsole(`[ZIP] Error fetching ${item.itemId} position 1: ${error.message}`, 'error');
                })
            );
          }
          
          // Download position 2 (URL2) image
          const url2Variant = item.url2Variants && item.url2Variants.length > 0 ? item.url2Variants[0] : null;
          if (url2Variant && !url2Variant.isPlaceholder && url2Variant.originalUrl !== '_PLACEHOLDER_') {
            const filename2 = `${item.itemId}_2`;
            // Get file extension from URL or default to .jpg
            const urlExt = url2Variant.originalUrl.match(/\.(jpg|jpeg|png|gif|webp)(\?|$)/i);
            const ext = urlExt ? urlExt[1] : 'jpg';
            const fullFilename2 = `${filename2}.${ext}`;
            
            imagePromises.push(
              fetch(url2Variant.originalUrl)
                .then(response => response.blob())
                .then(blob => {
                  zip.file(fullFilename2, blob);
                  logToConsole(`[ZIP] Added ${item.itemId} position 2: ${fullFilename2}`, 'info');
                })
                .catch(error => {
                  logToConsole(`[ZIP] Error fetching ${item.itemId} position 2: ${error.message}`, 'error');
                })
            );
          }
        });
        
        // Wait for all images to be added to zip
        await Promise.all(imagePromises);
        
        // Generate zip file
        logToConsole(`[ZIP] Generating zip file with ${imagePromises.length} images...`, 'info');
        const zipBlob = await zip.generateAsync({ type: 'blob' });
        
        // Generate timestamp in YYMMDD-HHMM format for filename
        const now = new Date();
        const year = now.getFullYear().toString().slice(-2);
        const month = String(now.getMonth() + 1).padStart(2, '0');
        const day = String(now.getDate()).padStart(2, '0');
        const hours = String(now.getHours()).padStart(2, '0');
        const minutes = String(now.getMinutes()).padStart(2, '0');
        const timestamp = `${year}${month}${day}-${hours}${minutes}`;
        const zipFilename = `downloaded_items_${timestamp}.zip`;
        
        // Download the zip file
        const link = document.createElement('a');
        link.href = URL.createObjectURL(zipBlob);
        link.download = zipFilename;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        setTimeout(() => URL.revokeObjectURL(link.href), 100);
        
        logToConsole(`[ZIP] Successfully created and downloaded: ${zipFilename}`, 'success');
        setGalleryStatus(`Downloaded ${zipFilename} with ${imagePromises.length} images.`);
        
        // Check if upload to Cloudinary is enabled
        const uploadAfterDownload = document.getElementById('uploadAfterDownloadGallery');
        if (uploadAfterDownload && uploadAfterDownload.checked) {
          try {
            logToConsole('Upload to Cloudinary after download enabled. Extracting zip and uploading images...', 'info');
            setGalleryStatus('Extracting zip and uploading to Cloudinary...');
            await uploadFromZipContent(zipBlob);
          } catch (uploadError) {
            logToConsole(`Upload error: ${uploadError.message || 'Unknown error'}`, 'error');
            setGalleryStatus(`Upload failed: ${uploadError.message || 'Unknown error'}`);
          }
        }
        
        document.getElementById('dlStatus').textContent = `Downloaded ${zipFilename} with ${imagePromises.length} images.`;
        closeGalleryModal();
      } catch (error) {
        logToConsole(`Error in finalizeGallerySelections: ${error.message || 'Unknown error'}`, 'error');
        setGalleryStatus(`Error: ${error.message || 'Unknown error'}`);
      } finally {
        // Always reset loading state, even if there was an error
        galleryLoading = false;
        updateGalleryToolbar();
      }
    }

    function handleCleanupClick() {
      alert('Clean Up CSV functionality will be implemented');
    }

    // Function to upload images from zip content
    // Accepts either a Blob or base64 string
    async function uploadFromZipContent(zipContent) {
      try {
        logToConsole('Extracting zip file...', 'info');
        
        let zip;
        // Handle both Blob and base64 string
        if (zipContent instanceof Blob) {
          // Load zip directly from blob
          zip = await JSZip.loadAsync(zipContent);
        } else {
          // Convert base64 to binary (legacy support)
          const binaryString = atob(zipContent);
          const bytes = new Uint8Array(binaryString.length);
          for (let i = 0; i < binaryString.length; i++) {
            bytes[i] = binaryString.charCodeAt(i);
          }
          zip = await JSZip.loadAsync(bytes);
        }
        logToConsole(`Zip extracted. Found ${Object.keys(zip.files).length} files.`, 'info');
        
        // Filter for image files and convert to File objects
        const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.bmp'];
        const imageFiles = [];
        
        for (const [filename, zipEntry] of Object.entries(zip.files)) {
          if (zipEntry.dir) continue; // Skip directories
          
          const ext = filename.toLowerCase().substring(filename.lastIndexOf('.'));
          if (imageExtensions.includes(ext)) {
            const blob = await zipEntry.async('blob');
            const file = new File([blob], filename, { type: blob.type });
            imageFiles.push(file);
            logToConsole(`Found image: ${filename}`, 'info');
          }
        }
        
        if (imageFiles.length === 0) {
          logToConsole('No image files found in zip.', 'error');
          setGalleryStatus('No images found in zip file.');
          return;
        }
        
        logToConsole(`Found ${imageFiles.length} image(s). Starting upload...`, 'info');
        
        // Use the shared upload function
        await uploadImageFiles(imageFiles);
        
      } catch (error) {
        console.error('‚ùå [UPLOAD] Error uploading from zip:', error);
        logToConsole(`Error uploading from zip: ${error.message}`, 'error');
        setGalleryStatus(`Upload error: ${error.message}`);
      }
    }
    
    // Shared upload function for both directory and zip uploads
    async function uploadImageFiles(imageFiles) {
      const uploadFolder = document.getElementById('upload_folder').value.trim();
      const uploadPreset = document.getElementById('upload_profile').value.trim();
      
      // Show progress bar
      const progressContainer = document.getElementById('uploadProgressContainer');
      const progressBar = document.getElementById('uploadProgressBar');
      const progressText = document.getElementById('uploadProgressText');
      const progressPercent = document.getElementById('uploadProgressPercent');
      const timeRemaining = document.getElementById('uploadTimeRemaining');
      
      if (progressContainer) progressContainer.style.display = 'block';
      if (progressBar) progressBar.style.width = '0%';
      if (progressText) progressText.textContent = `Uploading 0/${imageFiles.length} images...`;
      if (progressPercent) progressPercent.textContent = '0%';
      if (timeRemaining) timeRemaining.textContent = '';
      
      // Track upload times for time estimation
      let uploadTimes = [];
      
      try {
        // Create FormData for file upload
        const formData = new FormData();
        
        // Add folder and preset if provided
        if (uploadFolder) {
          formData.append('folder', uploadFolder);
        }
        if (uploadPreset) {
          formData.append('preset', uploadPreset);
        }
        
        // Add all image files
        imageFiles.forEach((file) => {
          formData.append('files', file);
        });
        
        // Use SSE for real-time progress
        logToConsole(`Starting upload of ${imageFiles.length} images to Cloudinary (real-time progress)...`, 'info');
        if (uploadFolder) {
          logToConsole(`Using folder: ${uploadFolder}`, 'info');
        }
        if (uploadPreset) {
          logToConsole(`Using preset: ${uploadPreset}`, 'info');
        }
        
        // Use EventSource-like approach with fetch and ReadableStream
        const response = await fetch('/api/upload_cloudinary_stream', {
          method: 'POST',
          body: formData
        });
        
        if (!response.ok) {
          throw new Error(`Upload failed: ${response.statusText}`);
        }
        
        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let buffer = '';
        let uploadedCount = 0;
        let failedCount = 0;
        let totalDuration = 0;
        const uploadedResults = [];
        const failedResults = [];
        let totalFiles = imageFiles.length;
        
        // Helper function to format file size
        function formatFileSize(bytes) {
          if (bytes < 1024) return bytes + ' B';
          if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
          return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
        }
        
        // Helper function to update progress
        function updateProgress(index, total, duration) {
          const percent = Math.round((index / total) * 100);
          if (progressBar) progressBar.style.width = percent + '%';
          if (progressPercent) progressPercent.textContent = percent + '%';
          if (progressText) progressText.textContent = `Uploading ${index}/${total} images...`;
          
          // Calculate estimated time remaining
          if (uploadTimes.length > 0 && index < total) {
            const avgTime = uploadTimes.reduce((a, b) => a + b, 0) / uploadTimes.length;
            const remaining = total - index;
            const estimatedSeconds = Math.round(avgTime * remaining);
            if (timeRemaining) {
              if (estimatedSeconds < 60) {
                timeRemaining.textContent = `~${estimatedSeconds}s remaining`;
              } else {
                const minutes = Math.floor(estimatedSeconds / 60);
                const seconds = estimatedSeconds % 60;
                timeRemaining.textContent = `~${minutes}m ${seconds}s remaining`;
              }
            }
          }
        }
        
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;
          
          buffer += decoder.decode(value, { stream: true });
          const lines = buffer.split('\n');
          buffer = lines.pop() || '';
          
          for (const line of lines) {
            if (line.startsWith('data: ')) {
              try {
                const data = JSON.parse(line.slice(6));
                
                switch (data.type) {
                  case 'start':
                    totalFiles = data.total;
                    logToConsole(`Starting upload of ${data.total} images...`, 'info');
                    break;
                    
                  case 'progress':
                    console.log(`‚¨ÜÔ∏è [UPLOAD] Progress: ${data.index}/${data.total} - ${data.filename}`);
                    break;
                    
                  case 'success':
                    uploadedCount++;
                    const successDuration = data.duration || 0;
                    uploadTimes.push(successDuration);
                    totalDuration += successDuration;
                    uploadedResults.push(data);
                    
                    // Find file size from original file list
                    const file = imageFiles.find(f => f.name.includes(data.filename));
                    const fileSize = file ? formatFileSize(file.size) : '';
                    const sizeText = fileSize ? ` (${fileSize})` : '';
                    
                    logToConsole(`‚úì [${data.index}/${data.total}] ${data.filename}${sizeText} (${data.duration}s) ‚Üí ${data.cloudinary_url}`, 'success');
                    updateProgress(data.index, data.total, successDuration);
                    break;
                    
                  case 'error':
                    failedCount++;
                    const errorDuration = data.duration || 0;
                    uploadTimes.push(errorDuration);
                    totalDuration += errorDuration;
                    failedResults.push(data);
                    
                    // Find file size from original file list
                    const errorFile = imageFiles.find(f => f.name.includes(data.filename));
                    const errorFileSize = errorFile ? formatFileSize(errorFile.size) : '';
                    const errorSizeText = errorFileSize ? ` (${errorFileSize})` : '';
                    
                    logToConsole(`‚úó [${data.index}/${data.total}] ${data.filename}${errorSizeText} (${data.duration}s): ${data.error}`, 'error');
                    updateProgress(data.index, data.total, errorDuration);
                    break;
                    
                  case 'complete':
                    const finalFailedCount = data.failed || 0;
                    if (progressBar) progressBar.style.width = '100%';
                    if (progressPercent) progressPercent.textContent = '100%';
                    if (timeRemaining) timeRemaining.textContent = '';
                    logToConsole(`‚úì Upload complete: ${data.successful} successful, ${finalFailedCount} failed (Total time: ${data.total_duration}s)`, 'success');
                    setGalleryStatus(`Upload complete: ${data.successful} successful, ${finalFailedCount} failed`);
                    alert(`Upload complete!\n\nSuccessful: ${data.successful}\nFailed: ${finalFailedCount}\nTotal time: ${data.total_duration}s\n\nCheck console for details.`);
                    break;
                }
              } catch (e) {
                console.error('‚¨ÜÔ∏è [UPLOAD] Error parsing SSE data:', e, line);
              }
            }
          }
        }
        
      } catch (error) {
        logToConsole(`Upload error: ${error.message}`, 'error');
        setGalleryStatus(`Upload error: ${error.message}`);
        alert(`Upload error: ${error.message}`);
      } finally {
        // Hide progress bar
        const progressContainer = document.getElementById('uploadProgressContainer');
        if (progressContainer) progressContainer.style.display = 'none';
      }
    }

    async function handleUploadClick() {
      console.log('‚¨ÜÔ∏è [UPLOAD] ========================================');
      console.log('‚¨ÜÔ∏è [UPLOAD] handleUploadClick() called');
      console.log('‚¨ÜÔ∏è [UPLOAD] ========================================');
      
      // Get the directory picker element
      const dirInput = document.getElementById('save_dir_file');
      const uploadFolder = document.getElementById('upload_folder').value.trim();
      
      console.log('‚¨ÜÔ∏è [UPLOAD] Initial state:', {
        dirInputExists: !!dirInput,
        filesCount: dirInput && dirInput.files ? dirInput.files.length : 0,
        uploadFolder: uploadFolder
      });
      
      logToConsole('Upload to Cloudinary button clicked...', 'info');
      
      // Check if directory has been selected
      const filesCount = dirInput && dirInput.files ? dirInput.files.length : 0;
      console.log('‚¨ÜÔ∏è [UPLOAD] Checking directory selection - filesCount:', filesCount);
      
      if (!dirInput || !dirInput.files || filesCount === 0) {
        console.log('‚¨ÜÔ∏è [UPLOAD] No directory selected, prompting user');
        logToConsole('Please select a directory first by clicking "Choose Directory" button.', 'error');
        alert('Please select a directory first by clicking "Choose Directory" button.\n\nThen select your images folder and confirm the upload dialog.');
        return;
      }
      
      console.log('‚¨ÜÔ∏è [UPLOAD] Directory selected - proceeding with upload');
      
      // Use the same filtering logic as preview
      const includeSubfoldersCheckbox = document.getElementById('include_subfolders');
      const includeSubfolders = includeSubfoldersCheckbox ? includeSubfoldersCheckbox.checked : false;
      
      console.log('‚¨ÜÔ∏è [UPLOAD] Checkbox state:', {
        checkboxExists: !!includeSubfoldersCheckbox,
        checked: includeSubfolders
      });
      
      console.log('‚¨ÜÔ∏è [UPLOAD] Calling filterImageFiles with', dirInput.files.length, 'files');
      let imageFiles = [];
      try {
        imageFiles = filterImageFiles(dirInput.files, includeSubfolders);
        console.log('‚¨ÜÔ∏è [UPLOAD] filterImageFiles completed successfully');
      } catch (error) {
        console.error('‚¨ÜÔ∏è [UPLOAD] Error in filterImageFiles:', error);
        logToConsole(`Error filtering files: ${error.message}`, 'error');
        alert(`Error filtering files: ${error.message}`);
        return;
      }
      
      // Filter to only selected images
      if (window.imageSelectionState) {
        const originalCount = imageFiles.length;
        imageFiles = imageFiles.filter(file => {
          const fileKey = file.webkitRelativePath || file.name;
          return window.imageSelectionState[fileKey] !== false; // Default true if not set
        });
        console.log('‚¨ÜÔ∏è [UPLOAD] After selection filter:', {
          originalCount: originalCount,
          selectedCount: imageFiles.length
        });
      }
      
      console.log('‚¨ÜÔ∏è [UPLOAD] Filtered result:', {
        imageFilesCount: imageFiles.length,
        totalFiles: dirInput.files.length
      });
      
      if (imageFiles.length === 0) {
        console.log('‚¨ÜÔ∏è [UPLOAD] No image files to upload');
        // Check if preview is showing - if so, use that info
        const previewContainer = document.getElementById('imagePreviewContainer');
        const previewVisible = previewContainer && previewContainer.style.display !== 'none' && previewContainer.style.display !== '';
        console.log('‚¨ÜÔ∏è [UPLOAD] Preview container state:', {
          exists: !!previewContainer,
          display: previewContainer ? previewContainer.style.display : 'N/A',
          visible: previewVisible
        });
        
        if (!previewVisible) {
          alert('No image files found in selected directory. Supported formats: JPG, PNG, GIF, WebP, BMP\n\nPlease select a directory with images or check "Include subfolders" if images are in subfolders.');
        } else {
          alert('No image files match the current filter settings. Try checking "Include subfolders" if your images are in subfolders.');
        }
        return;
      }
      
      const uploadBtn = document.getElementById('upBtn');
      const uploadPreset = document.getElementById('upload_profile').value.trim();
      
      console.log('‚¨ÜÔ∏è [UPLOAD] Starting upload process:', {
        imageCount: imageFiles.length,
        uploadFolder: uploadFolder,
        uploadPreset: uploadPreset
      });
      
      // Disable button during upload
      uploadBtn.disabled = true;
      const selectedCount = imageFiles.length;
      uploadBtn.textContent = `Uploading ${selectedCount} selected images...`;
      
      // Show progress bar
      const progressContainer = document.getElementById('uploadProgressContainer');
      const progressBar = document.getElementById('uploadProgressBar');
      const progressText = document.getElementById('uploadProgressText');
      const progressPercent = document.getElementById('uploadProgressPercent');
      const timeRemaining = document.getElementById('uploadTimeRemaining');
      
      if (progressContainer) progressContainer.style.display = 'block';
      if (progressBar) progressBar.style.width = '0%';
      if (progressText) progressText.textContent = `Uploading 0/${selectedCount} images...`;
      if (progressPercent) progressPercent.textContent = '0%';
      if (timeRemaining) timeRemaining.textContent = '';
      
      // Track upload times for time estimation
      let uploadTimes = [];
      
      try {
        // Create FormData for file upload
        const formData = new FormData();
        
        // Add folder and preset if provided
        if (uploadFolder) {
          formData.append('folder', uploadFolder);
          console.log('‚¨ÜÔ∏è [UPLOAD] Added folder to FormData:', uploadFolder);
        }
        if (uploadPreset) {
          formData.append('preset', uploadPreset);
          console.log('‚¨ÜÔ∏è [UPLOAD] Added preset to FormData:', uploadPreset);
        }
        
        // Add all image files
        console.log('‚¨ÜÔ∏è [UPLOAD] Adding files to FormData...');
        imageFiles.forEach((file, index) => {
          formData.append('files', file);
          if (index < 3) {
            console.log(`‚¨ÜÔ∏è [UPLOAD] Added file ${index + 1}:`, file.name);
          }
        });
        console.log(`‚¨ÜÔ∏è [UPLOAD] Total files added to FormData: ${imageFiles.length}`);
        
        // Use SSE for real-time progress
        logToConsole(`Starting upload of ${imageFiles.length} images to Cloudinary (real-time progress)...`, 'info');
        if (uploadFolder) {
          logToConsole(`Using folder: ${uploadFolder}`, 'info');
        }
        if (uploadPreset) {
          logToConsole(`Using preset: ${uploadPreset}`, 'info');
        }
        
        // Use EventSource-like approach with fetch and ReadableStream
        // Since EventSource doesn't support POST, we'll use fetch with streaming
        const response = await fetch('/api/upload_cloudinary_stream', {
          method: 'POST',
          body: formData
        });
        
        if (!response.ok) {
          throw new Error(`Upload failed: ${response.statusText}`);
        }
        
        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let buffer = '';
        let uploadedCount = 0;
        let failedCount = 0;
        let totalDuration = 0;
        const uploadedResults = [];
        const failedResults = [];
        let totalFiles = selectedCount;
        
        // Helper function to format file size
        function formatFileSize(bytes) {
          if (bytes < 1024) return bytes + ' B';
          if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
          return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
        }
        
        // Helper function to update progress
        function updateProgress(index, total, duration) {
          const percent = Math.round((index / total) * 100);
          if (progressBar) progressBar.style.width = percent + '%';
          if (progressPercent) progressPercent.textContent = percent + '%';
          if (progressText) progressText.textContent = `Uploading ${index}/${total} images...`;
          
          // Calculate estimated time remaining
          if (uploadTimes.length > 0 && index < total) {
            const avgTime = uploadTimes.reduce((a, b) => a + b, 0) / uploadTimes.length;
            const remaining = total - index;
            const estimatedSeconds = Math.round(avgTime * remaining);
            if (timeRemaining) {
              if (estimatedSeconds < 60) {
                timeRemaining.textContent = `~${estimatedSeconds}s remaining`;
              } else {
                const minutes = Math.floor(estimatedSeconds / 60);
                const seconds = estimatedSeconds % 60;
                timeRemaining.textContent = `~${minutes}m ${seconds}s remaining`;
              }
            }
          }
        }
        
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;
          
          buffer += decoder.decode(value, { stream: true });
          const lines = buffer.split('\n');
          buffer = lines.pop() || ''; // Keep incomplete line in buffer
          
          for (const line of lines) {
            if (line.startsWith('data: ')) {
              try {
                const data = JSON.parse(line.slice(6));
                
                switch (data.type) {
                  case 'start':
                    totalFiles = data.total;
                    logToConsole(`Starting upload of ${data.total} images...`, 'info');
                    break;
                    
                  case 'progress':
                    console.log(`‚¨ÜÔ∏è [UPLOAD] Progress: ${data.index}/${data.total} - ${data.filename}`);
                    break;
                    
                  case 'success':
                    uploadedCount++;
                    const successDuration = data.duration || 0;
                    uploadTimes.push(successDuration);
                    totalDuration += successDuration;
                    uploadedResults.push(data);
                    
                    // Find file size from original file list
                    const file = imageFiles.find(f => {
                      const fileKey = f.webkitRelativePath || f.name;
                      return fileKey.includes(data.filename);
                    });
                    const fileSize = file ? formatFileSize(file.size) : '';
                    const sizeText = fileSize ? ` (${fileSize})` : '';
                    
                    logToConsole(`‚úì [${data.index}/${data.total}] ${data.filename}${sizeText} (${data.duration}s) ‚Üí ${data.cloudinary_url}`, 'success');
                    uploadBtn.textContent = `Uploading ${data.index}/${data.total}...`;
                    updateProgress(data.index, data.total, successDuration);
                    break;
                    
                  case 'error':
                    failedCount++;
                    const errorDuration = data.duration || 0;
                    uploadTimes.push(errorDuration);
                    totalDuration += errorDuration;
                    failedResults.push(data);
                    
                    // Find file size from original file list
                    const errorFile = imageFiles.find(f => {
                      const fileKey = f.webkitRelativePath || f.name;
                      return fileKey.includes(data.filename);
                    });
                    const errorFileSize = errorFile ? formatFileSize(errorFile.size) : '';
                    const errorSizeText = errorFileSize ? ` (${errorFileSize})` : '';
                    
                    logToConsole(`‚úó [${data.index}/${data.total}] ${data.filename}${errorSizeText} (${data.duration}s): ${data.error}`, 'error');
                    uploadBtn.textContent = `Uploading ${data.index}/${data.total}...`;
                    updateProgress(data.index, data.total, errorDuration);
                    break;
                    
                  case 'complete':
                    const finalFailedCount = data.failed || 0;
                    if (progressBar) progressBar.style.width = '100%';
                    if (progressPercent) progressPercent.textContent = '100%';
                    if (timeRemaining) timeRemaining.textContent = '';
                    logToConsole(`‚úì Upload complete: ${data.successful} successful, ${finalFailedCount} failed (Total time: ${data.total_duration}s)`, 'success');
                    alert(`Upload complete!\n\nSuccessful: ${data.successful}\nFailed: ${finalFailedCount}\nTotal time: ${data.total_duration}s\n\nCheck console for details.`);
                    break;
                }
              } catch (e) {
                console.error('‚¨ÜÔ∏è [UPLOAD] Error parsing SSE data:', e, line);
              }
            }
          }
        }
        
      } catch (error) {
        logToConsole(`Upload error: ${error.message}`, 'error');
        alert(`Upload error: ${error.message}`);
      } finally {
        uploadBtn.disabled = false;
        uploadBtn.textContent = 'Upload to Cloudinary';
        // Hide progress bar
        const progressContainer = document.getElementById('uploadProgressContainer');
        if (progressContainer) progressContainer.style.display = 'none';
      }
    }

    async function handleWmUpdate(forceUseCsvData = false) {
      // Determine which CSV data to use
      // If forceUseCsvData is true (called from download process), always use csvData
      // Otherwise, prioritize loadedCsvData (manually loaded file) over csvData (downloaded CSV)
      
      console.error('=== handleWmUpdate START ===');
      console.error('forceUseCsvData:', forceUseCsvData);
      console.error('loadedCsvData:', loadedCsvData, 'type:', typeof loadedCsvData, 'isArray:', Array.isArray(loadedCsvData), 'length:', loadedCsvData?.length);
      console.error('csvData:', csvData, 'type:', typeof csvData, 'isArray:', Array.isArray(csvData), 'length:', csvData?.length);
      
      let csvDataToUse = null;
      
      if (forceUseCsvData) {
        csvDataToUse = csvData;
        console.log('Using csvData (forced from download), length:', csvDataToUse?.length);
      } else {
        // Manual call: prioritize manually loaded CSV over downloaded CSV
        // Simple direct check: is it an array with length > 0?
        console.error('DEBUG: Checking loadedCsvData...');
        console.error('DEBUG: loadedCsvData ===', loadedCsvData);
        console.error('DEBUG: Array.isArray(loadedCsvData) ===', Array.isArray(loadedCsvData));
        console.error('DEBUG: loadedCsvData?.length ===', loadedCsvData?.length);
        console.error('DEBUG: Full condition result ===', Array.isArray(loadedCsvData) && loadedCsvData.length > 0);
        
        if (Array.isArray(loadedCsvData) && loadedCsvData.length > 0) {
          console.error('DEBUG: Condition PASSED - assigning loadedCsvData');
          csvDataToUse = loadedCsvData;
          console.error('DEBUG: csvDataToUse after assignment ===', csvDataToUse);
          console.log('Using loadedCsvData, length:', csvDataToUse.length);
        } else {
          console.error('DEBUG: Condition FAILED for loadedCsvData');
          if (Array.isArray(csvData) && csvData.length > 0) {
            csvDataToUse = csvData;
            console.log('Using csvData (fallback), length:', csvDataToUse.length);
          } else {
            console.error('DEBUG: No valid CSV data found');
            console.log('No valid CSV data found');
          }
        }
      }
      
      console.error('csvDataToUse final:', csvDataToUse, 'length:', csvDataToUse?.length);
      
      if (!csvDataToUse || !Array.isArray(csvDataToUse) || csvDataToUse.length === 0) {
        console.error('ERROR: csvDataToUse is invalid:', csvDataToUse);
        console.error('ERROR: loadedCsvData at error time:', loadedCsvData);
        console.error('ERROR: csvData at error time:', csvData);
        alert('Please load a CSV file or download items first to create CSV data.');
        return;
      }

      // Get CSV input element for reference (used later for status updates)
      const csvOutInput = document.getElementById('csv_out');

      // Get ORG - check URL parameter first, then always prompt (unless from URL)
      let org = null;
      const urlParams = new URLSearchParams(window.location.search);
      const urlOrg = urlParams.get('Organization');
      
      if (urlOrg) {
        // ORG from URL - use it (should already be authenticated, no prompt)
        org = urlOrg.trim();
        if (sessionToken && sessionOrg === org) {
          // Already authenticated with this ORG, use stored token
        } else {
          // Need to authenticate
          const authResult = await apiCall('auth', { org });
          if (!authResult.success) {
            alert(`Authentication failed: ${authResult.error}`);
            return;
          }
          sessionToken = authResult.token;
          sessionOrg = org;
        }
      } else {
        // Always prompt for ORG, pre-populate with previous value if available
        org = prompt('Enter ORG for Manhattan WMS:', sessionOrg || '');
        if (!org || !org.trim()) return;
        org = org.trim();
        
        // Authenticate (always authenticate, even if ORG matches previous)
        const authResult = await apiCall('auth', { org });
        if (!authResult.success) {
          alert(`Authentication failed: ${authResult.error}`);
          return;
        }
        sessionToken = authResult.token;
        sessionOrg = org;
      }

      const wmBtn = document.getElementById('wmBtn');
      const dlStatus = document.getElementById('dlStatus');

      // Log API call with row count and first 2 item descriptions
      const rowCount = csvDataToUse.length;
      let itemDescriptions = '';
      if (rowCount > 0) {
        const firstTwo = csvDataToUse.slice(0, 2);
        const descriptions = firstTwo.map(row => {
          // CSV structure: [ItemId, ShortDescription, Description, ...]
          // Use Description (index 2) if available, fallback to ShortDescription (index 1) or ItemId (index 0)
          const desc = (row[2] && row[2].trim()) || (row[1] && row[1].trim()) || (row[0] && row[0].trim()) || 'N/A';
          return `'${desc}'`;
        });
        itemDescriptions = ` - First items: ${descriptions.join(', ')}`;
      }
      logToConsole(`Update WM: Calling API with ${rowCount} item(s)${itemDescriptions}`, 'info');

      // Show visual indicator
      wmBtn.disabled = true;
      wmBtn.innerHTML = '<span class="spinner-border spinner-border-sm me-2" role="status" aria-hidden="true"></span>Updating...';
      dlStatus.textContent = 'Updating WM...';

      try {
        const result = await apiCall('update_wm', {
          org,
          token: sessionToken,
          csv_data: csvDataToUse
        });

        if (result.success) {
          const summary = `Total: ${result.total}, Success: ${result.success_count}, Failed: ${result.failed_count}`;
          logToConsole(`Update WM succeeded - ${summary}`, 'success');
          alert(`WM Update Complete!\n\nTotal: ${result.total}\nSuccess: ${result.success_count}\nFailed: ${result.failed_count}`);
          dlStatus.textContent = `WM Update complete: ${result.success_count}/${result.total} successful`;
        } else {
          logToConsole(`Update WM failed: ${result.error}`, 'error');
          alert(`WM Update failed: ${result.error}`);
          dlStatus.textContent = `Error: ${result.error}`;
        }
      } catch (error) {
        logToConsole(`Update WM error: ${error.message}`, 'error');
        alert(`WM Update failed: ${error.message}`);
        dlStatus.textContent = `Error: ${error.message}`;
      } finally {
        wmBtn.disabled = false;
        wmBtn.innerHTML = 'Update WM';
      }
    }

    function registerEventHandlers() {
      logToConsole('[REGISTER] Starting registerEventHandlers()...', 'info');
      
      // Existing Item List Load button
      logToConsole('[REGISTER] Setting up existing list Load button...', 'info');
      const existingListBtn = document.getElementById('existingListLoadBtn');
      if (existingListBtn) {
        logToConsole('[REGISTER] Found existingListLoadBtn, adding event listener', 'info');
        existingListBtn.addEventListener('click', () => {
          logToConsole('[REGISTER] Load button clicked, triggering file input', 'info');
          const itemsFileInput = document.getElementById('items_file');
          if (itemsFileInput) {
            itemsFileInput.click();
          } else {
            logToConsole('[REGISTER] ERROR: items_file input not found', 'error');
          }
        });
        logToConsole('[REGISTER] ‚úì existingListLoadBtn event listener added', 'success');
      } else {
        logToConsole('[REGISTER] ERROR: existingListLoadBtn not found', 'error');
      }

      // Existing Item List file change handler
      logToConsole('[REGISTER] Setting up items_file change event listener...', 'info');
      const itemsFileInput = document.getElementById('items_file');
      if (itemsFileInput) {
        itemsFileInput.addEventListener('change', async (e) => {
          logToConsole('[REGISTER] items_file change event fired', 'info');
          try {
            if (!e.target.files.length) {
              logToConsole('[REGISTER] No files selected', 'warning');
              const existingListInput = document.getElementById('existing_list');
              existingListInput.value = '';
              existingListInput.removeAttribute('title');
              updateFileInputShading(existingListInput, true);
              setExistingListStatus('');
              localStorage.removeItem('item_gen_existing_list_filename');
              posItemsData = []; // Clear structured data
              return;
            }
            const file = e.target.files[0];
            logToConsole(`[REGISTER] File selected: ${file.name} (${file.size} bytes, type: ${file.type})`, 'info');
            
            // Validate file format before loading
            logToConsole('[REGISTER] Calling validateExistingListFile...', 'info');
            const validation = await validateExistingListFile(file);
            logToConsole(`[REGISTER] Validation result: valid=${validation.valid}, error=${validation.error || 'none'}, items=${validation.items?.length || 0}`, validation.valid ? 'success' : 'error');
          
            if (!validation.valid) {
              logToConsole(`[REGISTER] Validation failed: ${validation.error}`, 'error');
              // Show error message
              setExistingListStatus('');
              const existingListInput = document.getElementById('existing_list');
              existingListInput.value = '';
              existingListInput.removeAttribute('title');
              // Restore red shading to indicate file needs to be loaded
              updateFileInputShading(existingListInput, true);
              // Clear current item list data to force user to reload
              currentItemList = [];
              posItemsData = []; // Clear structured data
              setItemList([], 'No items loaded', false);
              localStorage.removeItem('item_gen_existing_list_filename');
              e.target.value = '';
              alert(`Invalid file format: ${validation.error}`);
              return;
            }

            logToConsole(`[REGISTER] File is valid! Processing ${validation.count} items...`, 'success');
            // File is valid, update display and load items
            // Display only filename (browsers don't provide full path for security)
            const existingListInput = document.getElementById('existing_list');
            const fileName = file.name;
            // Try to get folder path - browsers don't expose full path, but we can show folder\filename format
            let displayPath = fileName;
            if (file.webkitRelativePath) {
              // If file has relative path, use it
              const pathParts = file.webkitRelativePath.split('/');
              if (pathParts.length > 1) {
                displayPath = pathParts.slice(0, -1).join('\\') + '\\' + pathParts[pathParts.length - 1];
              }
            } else {
              // Try to extract folder from file path if available (limited browser support)
              // For now, show just filename - user can see full path in tooltip
              displayPath = fileName;
            }
            
            logToConsole(`[REGISTER] Setting display path: ${displayPath}`, 'info');
            existingListInput.value = displayPath;
            existingListInput.title = fileName; // Tooltip shows filename on hover
            // Remove red shading when file is loaded
            updateFileInputShading(existingListInput, false);
            // Store structured data for gallery use
            if (validation.structuredData) {
              posItemsData = validation.structuredData;
              logToConsole(`[REGISTER] Stored ${posItemsData.length} structured items in posItemsData`, 'success');
            } else {
              logToConsole('[REGISTER] WARNING: No structuredData in validation result', 'warning');
            }
            // Auto-apply when loading from file - no warnings, display in white
            logToConsole(`[REGISTER] Calling setItemList with ${validation.items.length} items...`, 'info');
            setItemList(validation.items, `${validation.count} items loaded from ${file.name}`, true);
            
            // Display green text with item count and header detection info
            const headerDetected = validation.headerDetected || false;
            const statusMessage = validation.count > 0
              ? headerDetected
                ? `${validation.count} items loaded (header row detected and skipped)`
                : `${validation.count} items loaded`
              : 'No items loaded';
            setExistingListStatus(statusMessage);
            
            logToConsole(`[REGISTER] ‚úì File loaded successfully: ${validation.count} items`, 'success');
            
            e.target.value = '';
          } catch (error) {
            logToConsole(`[REGISTER] EXCEPTION in items_file change handler: ${error.message}`, 'error');
            logToConsole(`[REGISTER] Stack trace: ${error.stack}`, 'error');
            console.error('[REGISTER] Error loading file:', error);
            alert(`Error loading file: ${error.message}`);
          }
        });
        logToConsole('[REGISTER] ‚úì items_file change event listener added', 'success');
      } else {
        logToConsole('[REGISTER] ERROR: items_file input not found', 'error');
      }
      
      const genBtn = document.getElementById('genBtn');
      if (genBtn) genBtn.addEventListener('click', handleGenerateClick);

      const dlBtn = document.getElementById('dlBtn');
      if (dlBtn) dlBtn.addEventListener('click', handleDownloadClick);

      const cleanupBtn = document.getElementById('cleanupBtn');
      if (cleanupBtn) cleanupBtn.addEventListener('click', handleCleanupClick);

      const uploadBtn = document.getElementById('upBtn');
      if (uploadBtn) {
        uploadBtn.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          handleUploadClick();
        });
      }

      const wmBtn = document.getElementById('wmBtn');
      if (wmBtn) wmBtn.addEventListener('click', () => handleWmUpdate(false));

      const galleryCloseBtn = document.getElementById('galleryCloseBtn');
      if (galleryCloseBtn) galleryCloseBtn.addEventListener('click', closeGalleryModal);

      const selectFirstBtn = document.getElementById('gallerySelectFirstBtn');
      if (selectFirstBtn) selectFirstBtn.addEventListener('click', selectFirstVariants);

      const refreshBtn = document.getElementById('galleryRefreshBtn');
      if (refreshBtn) refreshBtn.addEventListener('click', refreshGallery);

      const saveBtn = document.getElementById('gallerySaveBtn');
      if (saveBtn) saveBtn.addEventListener('click', finalizeGallerySelections);
      
      // Sync checkboxes between main section and gallery modal
      const uploadAfterDownload = document.getElementById('uploadAfterDownload');
      const uploadAfterDownloadGallery = document.getElementById('uploadAfterDownloadGallery');
      if (uploadAfterDownload && uploadAfterDownloadGallery) {
        // Sync main checkbox to gallery checkbox
        uploadAfterDownload.addEventListener('change', (e) => {
          uploadAfterDownloadGallery.checked = e.target.checked;
        });
        // Sync gallery checkbox to main checkbox
        uploadAfterDownloadGallery.addEventListener('change', (e) => {
          uploadAfterDownload.checked = e.target.checked;
        });
      }

      // Sync Update WM checkboxes between main section and gallery modal
      const updateWmAfterDownload = document.getElementById('updateWmAfterDownload');
      const updateWmAfterDownloadGallery = document.getElementById('updateWmAfterDownloadGallery');
      if (updateWmAfterDownload && updateWmAfterDownloadGallery) {
        // Sync main checkbox to gallery checkbox
        updateWmAfterDownload.addEventListener('change', (e) => {
          updateWmAfterDownloadGallery.checked = e.target.checked;
        });
        // Sync gallery checkbox to main checkbox
        updateWmAfterDownloadGallery.addEventListener('change', (e) => {
          updateWmAfterDownload.checked = e.target.checked;
        });
      }

      const galleryModalEl = document.getElementById('galleryModal');
      if (galleryModalEl) {
        galleryModalEl.addEventListener('click', (e) => {
          if (e.target === galleryModalEl) {
            closeGalleryModal();
          }
        });
      }

      const carouselModal = document.getElementById('carouselModal');
      const carouselCloseBtn = document.getElementById('carouselCloseBtn');
      const carouselPrevBtn = document.getElementById('carouselPrevBtn');
      const carouselNextBtn = document.getElementById('carouselNextBtn');
      const carouselUseBtn = document.getElementById('carouselUseBtn');
      if (carouselCloseBtn) carouselCloseBtn.addEventListener('click', closeVariantCarousel);
      if (carouselPrevBtn) carouselPrevBtn.addEventListener('click', () => shiftCarousel(-1));
      if (carouselNextBtn) carouselNextBtn.addEventListener('click', () => shiftCarousel(1));
      if (carouselUseBtn) carouselUseBtn.addEventListener('click', useCarouselImage);
      if (carouselModal) {
        carouselModal.addEventListener('click', (e) => {
          if (e.target === carouselModal) {
            closeVariantCarousel();
          }
        });
      }

      const scriptModal = document.getElementById('scriptModal');
      if (scriptModal) {
        scriptModal.addEventListener('click', (e) => {
          if (e.target === scriptModal) {
            closeScriptModal();
          }
        });
      }

      document.querySelectorAll('input, textarea').forEach(input => {
        input.addEventListener('change', saveConfig);
      });
    }

    window.addEventListener('DOMContentLoaded', () => {
      try {
        logToConsole('=== DOMContentLoaded event fired ===', 'info');
        logToConsole('Calling initUI()...', 'info');
        initUI();
        logToConsole('‚úì initUI() completed', 'success');
        
        logToConsole('Calling registerEventHandlers()...', 'info');
        registerEventHandlers();
        logToConsole('‚úì registerEventHandlers() completed', 'success');
        
        logToConsole('Calling app_opened API...', 'info');
        apiCall('app_opened', {});
        logToConsole('‚úì app_opened API called', 'success');
      } catch (error) {
        logToConsole(`ERROR during initialization: ${error.message}`, 'error');
        logToConsole(`Stack trace: ${error.stack}`, 'error');
        console.error('Initialization error:', error);
      }
      
      // Check for ORG in URL parameter and auto-authenticate if present
      const urlParams = new URLSearchParams(window.location.search);
      const urlOrg = urlParams.get('Organization');
      if (urlOrg && urlOrg.trim()) {
        // Auto-populate ORG and authenticate silently
        sessionOrg = urlOrg.trim();
        orgFromUrl = true;
        logToConsole(`ORG detected in URL: ${sessionOrg}. Auto-authenticating...`, 'info');
        
        // Auto-authenticate in background
        apiCall('auth', { org: sessionOrg }).then(authResult => {
          if (authResult.success) {
            sessionToken = authResult.token;
            logToConsole(`Auto-authentication successful for ORG: ${sessionOrg}`, 'success');
          } else {
            logToConsole(`Auto-authentication failed for ORG: ${sessionOrg} - ${authResult.error}`, 'error');
            sessionOrg = null;
            orgFromUrl = false;
          }
        }).catch(error => {
          logToConsole(`Auto-authentication error: ${error.message}`, 'error');
          sessionOrg = null;
          orgFromUrl = false;
        });
      }
      
      logToConsole(`To Do List ${APP_VERSION} initialized`, 'success');
      
      // Log instructions for viewing console
      console.log('%cüìä DEBUG LOGGING ENABLED', 'color: #00ff00; font-size: 16px; font-weight: bold;');
      console.log('%cTo view detailed logs:', 'color: #00ff00; font-size: 14px;');
      console.log('%c1. Press F12 (or Right-click ‚Üí Inspect)', 'color: #ffff00;');
      console.log('%c2. Click the "Console" tab', 'color: #ffff00;');
      console.log('%c3. Look for logs prefixed with: üîç [FILTER], üìã [PREVIEW], üìÅ [DIRECTORY], ‚¨ÜÔ∏è [UPLOAD], ‚òëÔ∏è [CHECKBOX]', 'color: #ffff00;');
      console.log('%cAll logs are prefixed with emojis for easy identification', 'color: #00ff00;');
    }); // End of window.addEventListener('DOMContentLoaded')
  </script>
</body>
</html>

